# 抽象与封装
## 抽象与封装的实现

**抽象：** 特殊 $\Rightarrow$ 一般

**封装：** 包装对象的属性和行为。用户通过对象的外部接口实现对对象的操作。

## 类
**类的定义**
```java
public class Box {
   int   length,width,height;     //成员变量

   void setLength(int lengthValue){ length=lengthValue;  }
   int   getLength(){   return length;} 
  
   void setWidth(int widthValue){ width=widthValue;  }
   int   getWidth(){  return width;}

   void setHeight(int heightValue){height=heightValue; }      
   int   getHeight(){  return height;}

    void setBox(int lengthValue,int widthValue,int  HeightValue) {    
          length=lengthValue; width=widthValue;         
          height=heightValue;                          //成员方法
     }
}
```
### 成员变量的定义与初始化
**定义**：[修饰符]  数据类型  成员变量　；
```java
class Point{
             int x,y;
             
             void setXY( int dx,int dy){x=dx;y=dy;}
             void setX{ int dx){x=dx;}
             void setY( int dy){y=dy;}
             int getX(){ return x;}
             int getY(){ return y;}
          }       
```
**初始化**
1) 没有初始化时，采用默认值：
    byte、short、int和long类型为0;
    float为0.0f ,double为0.0;　boolean为false;　
    char为‘\u0000’,　引用类型为null。
2) 定义的同时初始化:
```java
class Circle{
      Point position=new Point();
      float radius=10.0f;
      void setPosition(Point p)｛position.setXY(p.x,p.y);}
      float getRadius(){return radius;}
      float area(float r){return r*r*3.14159f;}
    }
```
3) 在成员方法中，初始化实例变量:
     Point类中的setXY(...)   setX()   setY() //建议采用:  软件开发常采用
4) 在类的构造方法中初始化实例变量。//建议采用
```java
class Point{
    int  x,y;
    Point(int dx,int dy){
        x=dx;y=dy;
       }
    }
```
5) 在初始化块中初始化成员变量。
```java
class Point{
       int  x,y;
        {
             x=10;
             y=20;
         }
       Point(){};
   }
```
**Note:  **
   1. 成员变量在被引用前，可不需初始化。而局部变量则一定要被初始化。
   2. 成员变量的数据类型可以是类本身
### 成员方法的定义
格式:[修饰符]  数据类型  成员方法(参数表){
　　方法体;
```java
public class Time{
         int  hour,minute,second;
         void setTime(int h,int  m,int s){
              hour=h;
              minute=m;
              second=s;
           }
          int  getHour(){return hour;}
          int  getMinute(){return minute;}
          int  getSecond(){return second;}
      }
```
### 成员方法的重载(overloading)：
具有相同名称,但参数不同(数目或类型)的成员方法时:
```java
public class Time {
    int hour, minute, second;

    void setTime(int h, int m, int s) {
        hour = h;
        minute = m;
        second = s;
    } //调用形式： setTime( 10,30,20 );

    void setTime(String time) {
        hour = Integer.parseInt(time.substring(0, 1));
        minute = Integer.parseInt(time.substring(3, 4));
        second = Integer.parseInt(time.substring(6, 7));
    } //调用形式： setTime("10:30:20");

    int getHour() {
        return hour;
    }

    int getMinute() {
        return minute;
    }

    int getSecond() {
        return second;
    }
}
```
```java
class Test {
   public int add(int x,int y){return x+y;}
   public float add(float x,float y){return x+y;}
   
   //以下两句参数相同，编译出错
   /*
   public int add2(int x ){return 1;}
   public float add2(int y ){return 1.0f;}
   */
   public static void main(String[] args) 	{
       Test t=new Test();		 
       System.out.println("Hello World!"+t.add(1,2));
       System.out.println("Hello World!"+t.add(1.0f,2.0f));
		 
	}
}
```
### 构造方法：没有返回类型。
**自定义构造方法**
```java
class Point {
    int x, y;

    // 构造方法
    Point(int dx, int dy) {
        x = dx;
        y = dy;
    }
}
```
**它没有显式地定义任何构造方法。**
中间的箭头 →: 表示“等价于”或“编译器会自动生成”。
```java
class Point {
    int x, y;
}
```
$\downarrow$
```java
class Point {
    int x, y;

    public Point() {
        super();
    }
}
}
```
**super();:** 这一行是自动包含的。它表示调用父类的无参数构造方法。在 Java 中，每个类的构造方法（无论是你写的还是编译器生成的）第一行都隐式或显式地调用 super()（如果不是 this()）。对于 Point 这样没有明确父类的类，它的父类就是 Object 类，所以 super() 调用的是 Object 类的构造方法。

**作用：** 有了这个默认构造方法，你就可以这样创建 Point 对象：
Point p2 = new Point(); // 这会创建一个 Point 对象 p2，其 x 和 y 将会被初始化为默认值（对于 int 来说是 0）。

**notice:**
1. 构造方法的主要作用是生成对象：new
2. 只要类中定义了构造方法，就没有默认的构造方法

```java
class  A{
    public  A(String str){
		System.out.println(str);
	}     
     public static void main(String[] args){ 
	//A a1= new A();
        A a2=new A("this is a a2 object ");		 
      }
}
```
### 构造方法的重载
```java
public class Time {
    int hour, minute, second; // 类的成员变量，用于存储时、分、秒

    // 第一个构造方法
    // 接受三个整数参数：小时、分钟、秒
    Time(int h, int m, int s) {
        hour = h;
        minute = m;
        second = s;
    } // 调用形式： Time( 10,30,20 );
      // 示例：Time t1 = new Time(10, 30, 20); // 创建一个时间为 10:30:20 的对象

    // 第二个构造方法
    // 接受一个字符串参数，表示时间（例如 "10:30:20"）
    Time(String time) {
        // 使用 Integer.parseInt() 将字符串转换为整数
        // time.substring(start, end) 截取字符串的一部分
        hour = Integer.parseInt(time.substring(0, 1)); // 截取小时部分（假定为一位数字）
        minute = Integer.parseInt(time.substring(3, 4)); // 截取分钟部分的第二位（注意这里可能是个bug，通常时间格式会是"HH:MM:SS"，截取0,1和3,4是不对的，应该是0,2和3,5）
                                                        // 根据图片中的调用形式 "10:30:20"，正确的截取应该是：
                                                        // hour = Integer.parseInt(time.substring(0, 2)); // "10"
                                                        // minute = Integer.parseInt(time.substring(3, 5)); // "30"
                                                        // second = Integer.parseInt(time.substring(6, 8)); // "20"
        second = Integer.parseInt(time.substring(6, 7)); // 截取秒部分的第二位（同上，可能是bug）
    } // 调用形式： Time("10:30:20");
      // 示例：Time t2 = new Time("10:30:20"); // 创建一个时间为 10:30:20 的对象

    // Getter 方法：用于获取时间的小时、分钟和秒
    int getHour() {
        return hour;
    }

    int getMinute() {
        return minute;
    }

    int getSecond() {
        return second;
    }
}
```
## 对象
### 对象的创建

1.  **声明对象：** `类名 对象名[,对象名];`
    例：`Box myBox;`

2.  **创建对象：** `new 构造方法([参数表]);`
    例：
    `myBox = new Box();`
    `time = new Time(09,20,45);`

3.  **声明与创建对象（一步完成）：**
    `Time timeObject3 = new Time("14:50:24");`
    `Time timeObject4 = new Time(09,20,45);`

### 对象的成员的使用：成员变量、成员方法

**引用成员变量：** `对象名.成员变量名;`
例：`timeObject3.hour;` `timeObject3.minute;`

**调用成员方法：** `对象名.成员方法(参数表);`
例：`timeObject3.getHour();`

**发送或响应消息：**

* **对象发送消息：** 对象发出**调用**自身或其它类对象的**成员方法**的命令。
* **对象响应消息：** 对象执行上述的调用命令。

例：
`timeObject3.getHour();`
`timeObject3.getMinute();`

### 对象的消除： 自动回收垃圾

* **对象在使用：** 系统为该对象做**标记**
* **对象不在使用：** 系统取消该对象的标记

**Java“垃圾回收器”** 周期性扫描所有对象的标记，没有标记的对象就列入清除的行列。待系统空闲或需要存储空间时将其回收。


## 访问属性控制:实现封装的目的
**访问属性：** 程序中**其它类**能否访问和调用它们。

**作用于：** **类**、**成员变量**、**成员方法**。

**四种：** 1. **默认访问属性**（即不写任何关键字）
2. **`public`** (公有访问属性)
3. **`private`** (私有访问属性)
4. **`protected`** (保护访问属性)

**notice:**

1.  **总的原则：** 只有在能访问类的前提下，才能访问该类中的成员变量和成员方法。

2.  但是**其它类**能否访问该类中的成员变量和成员方法，就要看该成员变量和成员方法的**访问属性**。

**格式：**

`[public|private|protected] 类名;`
`[public|private|protected] 成员变量名;`
`[public|private|protected] 成员方法;`

### 类的访问属性
**核心概念：** 访问属性（或访问修饰符）决定了类、成员变量、成员方法和构造方法在程序中的可见性。它们控制了哪些其他类可以访问或使用这些元素。

**顶层类 (Top-level Class) 的访问属性：**

“顶层类”指的是不嵌套在其他类内部的类。

一般只存在 public 类、默认类：
这说明对于顶层类，你通常只能使用两种访问修饰符：

**public 类：**

格式： public class 类名 { ... }
含义： 这种类在任何地方都可以被访问，无论是同一个包内还是不同的包。
限制： 一个 Java 源文件（.java 文件）中最多只能有一个 public 类，并且该 public 类的名称必须与源文件的文件名完全一致（包括大小写）。

**默认类 (包私有 - package-private)：**
格式： class 类名 { ... } (即不写任何访问修饰符)
含义： 这种类只能在同一个包内被访问。不同包的类无法访问它。

**Java 语言规范规定，顶层类不能用 private 或 protected 修饰。**

**private 类、protected 类：修饰内部类**
这部分是关键的修正和补充。它明确指出，private 和 protected 这两个访问修饰符不能用于修饰顶层类，它们只能用于修饰内部类（Inner Class 或 Nested Class）。

**private 内部类：**

含义： private 修饰的内部类只能在其外部类内部被访问。这提供了最严格的封装。
例子：
```Java

class OuterClass {
    private class InnerClass {
        // InnerClass 只能在 OuterClass 内部使用
    }
    public void someMethod() {
        InnerClass obj = new InnerClass(); // 可以在 OuterClass 内部创建 InnerClass 对象
    }
}
```
**protected 内部类：**

含义： protected 修饰的内部类可以在其外部类内部被访问，也可以在同一个包内的其他类中被访问，以及在外部类的子类内部被访问（即使子类在不同的包中）。
例子：
```Java

package com.example.package1;

class OuterClass {
    protected class ProtectedInnerClass {
        // ProtectedInnerClass 可以在 OuterClass 内部、同一个包的其他类中、
        // 以及 OuterClass 的子类中被访问。
    }
}

// 在同一个包的其他类中
class AnotherClassInSamePackage {
    public void test() {
        OuterClass.ProtectedInnerClass obj = new OuterClass().new ProtectedInnerClass();
    }
}

// 在不同包的子类中（假设 com.example.package2.SubClass 继承 OuterClass）
// 在 SubClass 内部可以访问 ProtectedInnerClass
```
### 成员的访问属性
1. public (公有访问属性）:可以被本类和其他任何类引用。
（这些类既可以位于同一个包中【同一个目录】，也可以
　位于不同包中【不同目录】 )
2.  protected:可访问性介于默认和public之间。
 可以被本类、本包中的类访问，和其他包中的子类继承。
3. 默认访问属性:没有指定访问属性。
只能被本类和同一个包中的其他类引用。(又称包属性)
4. private(私有)访问属性:实现数据隐藏
　　具有private属性的成员只能被本类直接引用
**实现了封装的目的：**
        用户对属性的访问只能通过类提供的方法实施。
         数据隐藏
         public 方法：接口

**总结：**
1. 在同一个包中(同一个目录中），可以访问public ,default类
2. 在同一个包中，在能访问类的条件下，除了private成员不能访问外，其它成员都能被访
3. 在不包中，在能访问类的条件下， 只能访问public成员
4. 无论修饰符如何定义，一个类总能访问它自已的成员变量和方法.

### 如何编写一个类？
     public  类
     private 成员变量
     private 成员方法
     必要的public  成员方法: 接口

### 访问属性的 UML语言描述
public :     +　
private:     -
protected :#
默认：
```java
class Student{
	public String name;
	private  int  age;
	protected String no;
	public Student(String sName,int sAge,String sNo){
		name=sName;  age=sAge;no=sNo;
	  }
	public String getName(){return name;}
          public int getAge(){  return age;}
	protected String getNo(){return no;)
}
```
```java
public class Complex
{
    // 私有字段，用于存储复数的虚部 (imaginary part)
    private int image; 
    // 私有字段，用于存储复数的实部 (real part)
    private int real; 

    // 带参数的构造函数
    // 接受两个整数作为参数，分别初始化复数的虚部和实部
    public Complex(int image, int real)
    {
        this.image = image; // 将传入的image参数赋值给当前对象的image字段
        this.real = real;   // 将传入的real参数赋值给当前对象的real字段
    }

    // 无参数的默认构造函数
    // 当没有提供参数来创建Complex对象时，会调用此构造函数。
    // 在本例中，它不执行任何操作，因此image和real字段将保持其默认值（对于int类型是0）。
    public Complex()
    {
    }

    // 复数加法方法
    // 接受另一个Complex对象作为参数，表示要相加的第二个复数
    public Complex add(Complex second)
    {
        // 创建一个新的Complex对象来存储加法结果
        Complex result = new Complex(); 
        
        // 将当前对象的虚部与第二个对象的虚部相加，结果赋给result对象的虚部
        // 注意：此实现只处理了虚部的加法，实部并未相加。
        // 如果要完整实现复数加法，还需要加上：result.real = this.real + second.real;
        result.image = this.image + second.image; 
        
        // 返回包含加法结果的Complex对象
        return result;
    }

    // 获取虚部的方法（getter）
    // 返回当前对象的虚部值
    public int getImage()
    {
        return image;
    }

    // 假设可能还有获取实部的方法，但图中未显示
    /*
    public int getReal()
    {
        return real;
    }
    */
}
```


## 静态成员

类成员:
1. **静态的(static)**，称为类成员：类变量、类方法
2. **非静态的**，称为实例成员：实例变量、实例方法

### 类变量的定义与初始化

**类变量的定义:** `[访问属性] static 数据类型 成员变量`

**例:**
* `public static int i=0;`
* `private static String name;`

## 引用类变量

**不需要实例化类，就可访问类变量**

1.  `类名.类变量;`
2.  `对象名.类变量;`

**例:**
* `zhang.id;`
* `Employee.id;`

(访问实例变量，必须先要**实例化类(生成对象)**，再通过对象来访问实例变量。)

**类变量与实例变量的区别:**
* **实例变量**只属于**具体的对象**，
* **类变量**为**所有的对象共享**

### 类方法:[访问属性] static 数据类型 成员方法()
```java
public static int getAge(){
           …
        }
public static void main(String[] args){
             …
　　}
```
### 引用类方法

**不需要实例化类，就可访问类方法**

1.  `类名.类方法();`
2.  `对象名.类方法()`

**notice:**
类方法只能操作该方法中的局部变量和**类变量**，而不能访问实例变量和实例方法。

### uml语言描述类成员：下划线

## 理解JVM运行程序的过程
## final、this和null修饰符
1. **final修饰符**
final 变量：常量
final 成员方法：禁止子类覆盖该方法。
final 类：禁止被继承。
2. **this修饰符**:代表当前对象的一个引用。
调用实例方法，引用实例成员时：自动加上this
```java
public Employee(String n,double s){
          name=n;
          salary=s;
         id=nextId;
       }
```
**编译器自动加上this**
```java
public Employee(String n,double s){
             this.name=n;
             this.salary=s;
             this.id=nextId;
        }

```
3. **null修饰符:**引用型变量为空的状态。
```java
    Employee Tom=new Employee(“TOM”,800);
    Tom=null;
```
当Tom = null;这行代码执行后，如果之前创建的那个“TOM”员工对象（名字叫"TOM"，值为800的那个）不再有任何其他变量“指着”它，那么它就变成了一个“无主”的对象。在像Java或C#这样的编程语言中，有一个叫做“垃圾回收器 (Garbage Collector)”的机制，它会在后台自动运行，专门寻找这些“无主”的对象，并把它们占用的内存空间清理掉，以便这些内存可以被程序的其他部分重新使用。

## 内部类
```java
public class Outer { 
　　public class Inner {
　　　 private int i;
　　　 public void innerMethod(){} 
　　}
       public void outerMethod(){} 
 }　
```
### notice:
1.  内部类只有在外部类的范围内可知。
2.  内部类可以访问外部类的成员，反过来不成立。
3.  如果要在外部类之外访问内部类，首先要创建一个外部类的对象，再通过该对象来创建内部类的对象。

### 内部类种类 (Types of Inner Classes):
**定义在类中的内部类 (Inner class defined within a class)**
这种内部类也常被称为“成员内部类”或“非静态内部类”。它与外部类的成员（字段和方法）地位相似，可以访问外部类的所有成员，包括私有成员。

例 (Example):

```Java

// OuterClass.java
public class OuterClass {
    private String outerMessage = "Hello from OuterClass!";

    // 这是一个定义在类中的内部类
    public class MemberInnerClass {
        public void display() {
            System.out.println("Inner class can access: " + outerMessage);
            // 内部类可以访问外部类的私有成员
        }
    }

    public void createAndUseInnerClass() {
        MemberInnerClass inner = new MemberInnerClass();
        inner.display();
    }

    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        outer.createAndUseInnerClass();

        // 在外部类之外创建成员内部类对象需要先有外部类对象
        OuterClass.MemberInnerClass anotherInner = outer.new MemberInnerClass();
        anotherInner.display();
    }
}
```
**定义在块中的内部类 (Inner class defined within a block)**
这种内部类被称为“局部内部类”。它定义在一个方法或任何局部作用域（如if块、for循环等）内。局部内部类在定义它的块之外是不可见的，并且不能用访问修饰符（public, private, protected）。

例 (Example):

```Java

// InnerClassInBlock.java
public class MyClass {
    public void someMethod() {
        int x = 10; // 局部变量，局部内部类可以访问 final 或 effectively final 的局部变量

        // 这是一个定义在方法（块）中的内部类
        class LocalInnerClass {
            public void printMessage() {
                // 局部内部类可以访问外部方法中的局部变量（要求是final或effectively final）
                System.out.println("Value of x from local inner class: " + x);
            }
        }

        LocalInnerClass local = new LocalInnerClass();
        local.printMessage();
    }

    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.someMethod();
    }
}
```
**定义在方法中的内部类 (Inner class defined within a method)**
这个其实和第二种“定义在块中的内部类”是同一个概念，因为方法体本身就是一个“块”。

例 (Example - same as above for clarity):

```Java

// InnerClassInMethod.java (Content similar to InnerClassInBlock.java)
public class AnotherClass {
    public void executeTask() {
        String taskName = "Background Task";

        // 这是一个定义在方法中的内部类
        class TaskRunner {
            public void run() {
                System.out.println("Running: " + taskName);
            }
        }

        TaskRunner runner = new TaskRunner();
        runner.run();
    }

    public static void main(String[] args) {
        AnotherClass obj = new AnotherClass();
        obj.executeTask();
    }
}
```
**匿名类 (Anonymous Class)**
匿名类是一种没有名字的内部类。它通常在需要创建一次性使用的类的实例时使用，例如实现一个接口或扩展一个类。匿名类必须在创建时立即定义和实例化。

例 (Example):

```Java

// AnonymousClassDemo.java

// 定义一个接口
interface Greeting {
    void sayHello();
}

// 定义一个抽象类
abstract class Animal {
    abstract void makeSound();
}

public class AnonymousClassDemo {
    public static void main(String[] args) {
        // 匿名类实现接口
        Greeting englishGreeting = new Greeting() {
            @Override
            public void sayHello() {
                System.out.println("Hello!");
            }
        };
        englishGreeting.sayHello();

        // 匿名类扩展抽象类
        Animal dog = new Animal() {
            @Override
            void makeSound() {
                System.out.println("Woof woof!");
            }
        };
        dog.makeSound();

        // 匿名类也可以用于方法参数，例如事件监听器
        // new Thread(new Runnable() {
        //     @Override
        //     public void run() {
        //         System.out.println("Anonymous Runnable running!");
        //     }
        // }).start();
    }
}
```
```java
new AnonymousParent(){
    private int i=1;
    public void prtI(){
        System.out.println(i);
    }
};
```
**类似于**
```java
class MyP extends AnonymousParent {
    private int i=1;
    public void prtI(){
        System.out.println(i);
    }
};
new MyP();
```

## 对象拷贝
# 对象拷贝与赋值的概念

## 深拷贝 (Deep Copy)

* **中文定义**：对象的完整拷贝。仅拷贝对象的内容。
* **详细解释**：深拷贝意味着对一个对象进行**完全的复制**。它不仅复制了对象本身的字段值，而且如果对象内部包含对其他对象的引用（即嵌套对象），深拷贝会**递归地复制**这些被引用的嵌套对象，直到所有层级的对象都被独立复制。最终，原对象和新对象是**完全独立**的，修改其中一个不会影响另一个。
* **英文定义**：A complete copy of an object. Only copies the content of the object.
* **English Explanation**: Deep copy involves creating a **completely independent copy** of an object. This means that not only are the primitive field values copied, but if the object contains references to other objects (nested objects), deep copy will **recursively copy** those referenced objects as well, until all levels of objects are independently duplicated. Consequently, the original object and the new object are **entirely separate**, and changes to one will not affect the other.

## 浅拷贝 (Shallow Copy) 与对象克隆 (Cloning)

* **2 对象拷贝 (对象本身内容的拷贝)**：cloning (克隆)。
* **中文定义**：按照二进制位串进行对象的拷贝，新拷贝的对象严格地复制原对象。
* **详细解释**：浅拷贝是一种“位对位”的复制。它会创建一个**新对象**，并将原对象的所有字段值复制到新对象中。
    * 如果原对象的字段是**基本数据类型**（如 `int`, `boolean` 等），则会复制其值，新对象拥有独立的该字段。
    * 但如果原对象的字段是**对其他对象的引用**（即引用类型），那么浅拷贝只会复制这个“引用”本身（即内存地址），而不会去复制引用所指向的那个“其他对象”。
    * 这意味着原对象和新对象会**共享**这些被引用的子对象。如果通过新对象修改了共享的子对象，原对象也会看到这些变化，反之亦然。
* **英文定义**：Copies the object according to its binary bit sequence. The newly copied object strictly replicates the original object.
* **English Explanation**: Shallow copy performs a "bit-wise" copy of an object. It creates a **new object** and copies all field values from the original object to the new one.
    * If the original object's fields are **primitive data types** (like `int`, `boolean`, etc.), their values are copied, and the new object has its own independent copy of these fields.
    * However, if the original object's fields are **references to other objects** (i.e., reference types), shallow copy only copies the "reference" itself (the memory address), not the "other object" that the reference points to.
    * This implies that both the original object and the new object will **share** these referenced sub-objects. If a change is made to a shared sub-object through the new object, the original object will also reflect this change, and vice versa.

* **例**：利用 `Point` 型对象 `p1` 和 `p2`，创建一个 `Rect` 型对象 `r2`、`r3`。如果将 `r2` 浅拷贝给 `r3`，则结果如下图所示（*注：图中未提供具体的视觉示例，但原理如上所述*）。
* **Example**: Using `Point` objects `p1` and `p2`, create a `Rect` object `r2`, `r3`. If `r2` is shallow-copied to `r3`, the result is as shown in the figure below (*Note: The visual example is not provided, but the principle is as described above*).

## 引用型变量的赋值 (Assignment of Reference Type Variables)

* **1 引用型变量的赋值**：
* **中文解释**：这是最基本且常见的操作，与对象拷贝（无论是深拷贝还是浅拷贝）有着本质的区别。
    * `Employee e1, e2;`
        * 声明两个 `Employee` 类型的引用变量 `e1` 和 `e2`。此时，它们都只是声明，尚未指向任何具体的对象。
    * `e1 = new Employee(“E1”, 3000);`
        * 在内存中**创建一个新的 `Employee` 对象**（假定名字为“E1”，薪水为3000）。
        * 将这个新创建对象的内存地址（或者说，指向它的“引用”）赋值给变量 `e1`。现在 `e1` 就“指向”了这个新对象。
    * `e2 = e1;`
        * **关键一步**：将 `e1` 中存储的内存地址（那个“引用”）**复制并赋值**给 `e2`。
        * 这意味着 `e2` 现在也**指向了与 `e1` 完全相同的那个 `Employee` 对象**。
        * 此时，内存中**只有一个 `Employee` 对象**，但有两个变量（`e1` 和 `e2`）都引用着它。
* **结果**：通过 `e1` 对该对象做出的任何修改，都将通过 `e2` 看到，反之亦然，因为它们操作的是同一个内存中的对象实例。这与创建新对象的拷贝操作（深拷贝或浅拷贝）是截然不同的。
* **English Explanation**: This is the most basic and common operation, fundamentally different from object copying (whether deep or shallow).
    * `Employee e1, e2;`
        * Declares two reference variables, `e1` and `e2`, of type `Employee`. At this point, they are merely declared and do not point to any specific object.
    * `e1 = new Employee(“E1”, 3000);`
        * **Creates a new `Employee` object** in memory (e.g., with name "E1" and salary 3000).
        * Assigns the memory address (or "reference") of this newly created object to the variable `e1`. So, `e1` now "points" to this new object.
    * `e2 = e1;`
        * **Crucial step**: The memory address (the "reference") stored in `e1` is **copied and assigned** to `e2`.
        * This means that `e2` now also **points to the exact same `Employee` object as `e1`**.
        * At this point, there is **only one `Employee` object** in memory, but two variables (`e1` and `e2`) are referencing it.
* **Result**: Any changes made to the object through `e1` will be visible through `e2`, and vice-versa, because they are operating on the same single object instance in memory. This is distinctly different from object copying operations (deep or shallow copy), which involve creating new object instances.

Java 实现对象拷贝：实现 Cloneable 接口，并对该接口中的 clone() 方法重写。
Java object cloning implementation: Implement the Cloneable interface and override the clone() method within this interface.

**notice:**

1. clone() 返回的是 Object 类对象，需强制类型转换。
1. clone() returns an Object class object, requiring a forced type conversion.

2. clone() 方法实现的是浅拷贝。
2. The clone() method implements a shallow copy.

Here's an example in Java demonstrating object cloning using the `Cloneable` interface and the `clone()` method, along with an explanation of shallow copy.

这是一个用 Java 演示对象克隆的例子，使用了 `Cloneable` 接口和 `clone()` 方法，并解释了浅拷贝。

```java
// Define a class representing an Address (地址类)
class Address implements Cloneable {
    public String city; // 城市
    public String street; // 街道

    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }

    @Override
    public String toString() {
        return "Address [city=" + city + ", street=" + street + "]";
    }

    // This is optional for shallow copy, but needed for deep copy of Address if desired
    // (浅拷贝不需要，但如果想实现Address的深拷贝，则需要)
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

// Define a class representing a Student (学生类)
class Student implements Cloneable {
    public String name; // 姓名
    public int age; // 年龄
    public Address address; // 地址 (引用类型)

    public Student(String name, int age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    @Override
    public String toString() {
        return "Student [name=" + name + ", age=" + age + ", address=" + address + "]";
    }

    @Override
    // Override the clone method (重写clone方法)
    protected Object clone() throws CloneNotSupportedException {
        // Performing a shallow copy here (这里进行的是浅拷贝)
        return super.clone();

        /*
        // To perform a deep copy for the 'address' field (如果需要对'address'字段进行深拷贝，可以这样做):
        Student clonedStudent = (Student) super.clone();
        clonedStudent.address = (Address) this.address.clone(); // Assuming Address also implements Cloneable
        return clonedStudent;
        */
    }
}

public class CloneExample {
    public static void main(String[] args) {
        // Original Address object (原始地址对象)
        Address originalAddress = new Address("New York", "123 Main St");

        // Original Student object (原始学生对象)
        Student originalStudent = new Student("Alice", 20, originalAddress);

        System.out.println("Original Student: " + originalStudent);
        System.out.println("Original Address in Student: " + originalStudent.address);
        System.out.println("----------------------------------------");

        try {
            // Clone the student object (克隆学生对象)
            // Notice: clone() returns Object, so a cast is needed (注意：clone()返回Object，所以需要强制类型转换)
            Student clonedStudent = (Student) originalStudent.clone();

            System.out.println("Cloned Student:   " + clonedStudent);
            System.out.println("Cloned Address in Student: " + clonedStudent.address);
            System.out.println("----------------------------------------");

            // Verify if they are different objects (验证它们是否是不同的对象)
            System.out.println("originalStudent == clonedStudent: " + (originalStudent == clonedStudent)); // Should be false (应该是false)
            System.out.println("originalStudent.address == clonedStudent.address: " + (originalStudent.address == clonedStudent.address)); // For shallow copy, this is true! (对于浅拷贝，这个是true!)

            System.out.println("\n--- Modifying original student's address ---");
            // Modify the original student's address (修改原始学生的地址)
            originalStudent.address.street = "456 Oak Ave";
            originalAddress.city = "Los Angeles"; // Also changes the originalAddress object directly

            System.out.println("Original Student (after modification): " + originalStudent);
            System.out.println("Cloned Student (after modification of original): " + clonedStudent); // Notice the address also changed! (注意地址也变了！)
            System.out.println("----------------------------------------");

        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            System.out.println("Cloning not supported for this object.");
            System.out.println("该对象不支持克隆。");
        }
    }
}
```
## 传值、传引用

###  基本数据类型是传值

方法形参的值在方法体内改变的结果不会反映到方法体外。

###  引用数据类型是传引用

方法形参的值在方法体内改变的结果会反映到方法体外。

### Java程序运行时的内存分配(重点)
Java 程序运行时的内存分配是 Java 虚拟机 (JVM) 的一个核心概念，它决定了程序如何存储数据和执行代码。理解 JVM 内存结构对于编写高效、避免内存泄漏的 Java 应用程序至关重要。

### Java 内存区域概述 (Overview of Java Memory Areas)

JVM 将内存划分为几个主要的运行时数据区域，它们在程序执行期间扮演不同的角色：

1.  **堆 (Heap)**
    * **用途 (Purpose):** 堆是 JVM 管理的最大一块内存区域，用于存储所有对象实例和数组。所有通过 `new` 关键字创建的对象都分配在堆上。
    * **特点 (Characteristics):**
        * **共享 (Shared):** 堆是所有线程共享的内存区域。
        * **动态分配 (Dynamic Allocation):** 对象的内存是在运行时动态分配的。
        * **垃圾回收 (Garbage Collection):** 堆内存由 Java 的垃圾回收器 (Garbage Collector, GC) 自动管理。当对象不再被任何引用指向时，GC 会自动回收其占用的内存。
        * **分代 (Generational):** 为了提高垃圾回收效率，堆通常被划分为不同的代：
            * **新生代 (Young Generation):** 新创建的对象首先分配在这里。新生代又分为一个 Eden 区和两个 Survivor 区 (S0 和 S1)。
            * **老年代 (Old Generation / Tenured Generation):** 经过多次垃圾回收仍存活的对象会被晋升到老年代。
            * **（了解）永久代/元空间 (PermGen / Metaspace):** 在 Java 8 之前有永久代，主要存储类的元数据、运行时常量池等。Java 8 及之后，永久代被元空间 (Metaspace) 取代，元空间使用本地内存，而不是 JVM 内存。
    * **OOM (Out Of Memory) Error:** 如果堆内存耗尽，会抛出 `java.lang.OutOfMemoryError: Java heap space`。

2.  **栈 (Stack)**
    * **用途 (Purpose):** 每个线程在运行时都有一个私有的栈。栈用于存储局部变量、方法参数、操作数栈以及方法调用的信息（如方法返回地址）。
    * **特点 (Characteristics):**
        * **线程私有 (Thread-Private):** 每个线程都有自己的栈，因此栈内存是线程安全的。
        * **LIFO (Last-In, First-Out):** 栈是一种后进先出 (LIFO) 的数据结构。每次方法调用都会创建一个新的栈帧 (Stack Frame) 并压入栈顶，当方法执行完毕后，对应的栈帧就会从栈中弹出。
        * **自动分配与回收 (Automatic Allocation and Deallocation):** 栈内存的分配和回收是自动进行的，不需要手动管理。当方法进入时，为该方法分配栈帧；当方法退出时，栈帧被销毁。
        * **存储内容 (Content):**
            * **局部变量 (Local Variables):** 存储基本数据类型（`int`, `boolean`, `char`, `float` 等）的局部变量的值，以及对象引用（指向堆中对象的地址）。
            * **方法参数 (Method Parameters):** 存储传递给方法的参数。
            * **操作数栈 (Operand Stack):** 用于存储执行指令的中间结果。
            * **帧数据 (Frame Data):** 包括方法返回地址等。
    * **SOF (Stack Overflow) Error:** 如果栈深度超过 JVM 允许的最大深度（例如，无限递归调用），会抛出 `java.lang.StackOverflowError`。

3.  **方法区 (Method Area)**
    * **用途 (Purpose):** 方法区是一个所有线程共享的内存区域，用于存储已被 JVM 加载的类信息、常量、静态变量以及编译后的代码（如方法信息、字段信息、运行时常量池等）。
    * **特点 (Characteristics):
        * **共享 (Shared):** 与堆一样，方法区也是所有线程共享的。
        * **内存回收 (Memory Reclamation):** 方法区也有垃圾回收，主要针对常量池的回收和对类型的卸载。
        * **Java 8 及之后 (Java 8 and onwards):** 在 Java 8 中，方法区被 **元空间 (Metaspace)** 所取代。元空间不在 JVM 内存中，而是使用本地内存（操作系统分配的内存）。这使得 JVM 可以更好地管理元数据，减少了 `OutOfMemoryError: PermGen space` 的发生。

4.  **程序计数器 (Program Counter Register, PC Register)**
    * **用途 (Purpose):** 每个线程都有一个私有的程序计数器。它存储着当前线程正在执行的 Java 虚拟机字节码指令的地址。如果当前方法是 Native 方法，则该寄存器的值为 undefined。
    * **特点 (Characteristics):**
        * **线程私有 (Thread-Private):** 保证了线程切换后能够恢复到正确的执行位置。
        * **内存空间小 (Small Memory Space):** 这是 JVM 内存区域中唯一一个不会出现 `OutOfMemoryError` 的区域。

5.  **本地方法栈 (Native Method Stacks)**
    * **用途 (Purpose):** 本地方法栈与 JVM 栈类似，但它为 JVM 执行 Native 方法（即用 C/C++ 等非 Java 语言编写的方法）服务。
    * **特点 (Characteristics):**
        * **线程私有 (Thread-Private):** 每个线程都有一个。
        * **OOM / SOF:** 同样可能抛出 `OutOfMemoryError` 或 `StackOverflowError`。

### 内存分配示例 (Memory Allocation Example)

让我们通过一个简单的 Java 代码示例来理解这些内存区域如何协作：

```java
public class MemoryExample {
    private static String staticField = "Hello Static"; // 1. 静态变量

    public void myMethod(int parameterValue) { // 2. 方法参数
        int localVariable = 100; // 3. 局部变量 (基本类型)
        String myString = new String("Java"); // 4. 对象和引用
        
        System.out.println(staticField);
        System.out.println(localVariable);
        System.out.println(myString);
    }

    public static void main(String[] args) {
        MemoryExample obj = new MemoryExample(); // 5. 对象创建
        obj.myMethod(50); // 6. 方法调用
    }
}
```
### 内存分配过程 (Memory Allocation Process):

1.  **加载类文件 (Loading Class Files):**
    * 当 `MemoryExample` 类被加载时，其元数据（包括 `staticField` 的定义、`myMethod` 和 `main` 方法的字节码）会被存储在 **方法区 (Method Area)**（或元空间）。

2.  **`main` 方法执行 (Execution of `main` method):**
    * JVM 为 `main` 方法创建一个栈帧并压入当前线程的 **栈 (Stack)**。
    * `obj` 是一个局部变量（引用类型），它的引用（指向堆中对象的地址）存储在 `main` 方法的栈帧中。
    * `new MemoryExample()` 会在 **堆 (Heap)** 上创建一个 `MemoryExample` 对象。

3.  **`obj.myMethod(50)` 调用 (`obj.myMethod(50)` Call):**
    * 当 `myMethod` 被调用时，JVM 为 `myMethod` 创建一个新的栈帧，并将其压入栈顶。
    * `parameterValue` (值 `50`) 是一个方法参数，它存储在 `myMethod` 的栈帧中。
    * `localVariable` (值 `100`) 是一个局部变量（基本类型），它存储在 `myMethod` 的栈帧中。
    * `myString` 是一个局部变量（引用类型），它的引用存储在 `myMethod` 的栈帧中。
    * `new String("Java")` 会在 **堆 (Heap)** 上创建一个 `String` 对象。`"Java"` 这个字符串字面量本身可能会在字符串常量池中（通常也在堆的一部分区域）。

4.  **`myMethod` 执行完毕 (`myMethod` Finishes):**
    * 当 `myMethod` 执行完毕时，其对应的栈帧会从栈中弹出，`parameterValue`、`localVariable` 和 `myString` 的引用都会被销毁。
    * 此时，堆中的 `String` 对象如果不再被其他地方引用，就会成为垃圾回收的候选对象。

5.  **`main` 方法执行完毕 (`main` Finishes):**
    * 当 `main` 方法执行完毕时，其栈帧也会从栈中弹出，`obj` 的引用被销毁。
    * 此时，堆中的 `MemoryExample` 对象如果不再被引用，也会成为垃圾回收的候选对象。

6.  **`staticField` (`staticField`):**
    * `staticField` 是一个静态变量，它的值 `"Hello Static"` 存储在 **方法区 (Method Area)**（或元空间）中，因为它属于类本身，而不是某个对象实例。它随着类的加载而存在，直到类被卸载。

好的，我已经阅读了您提供的所有图片内容。这些图片主要围绕 Java 虚拟机 (JVM) 的类加载过程、内存分配以及相关概念进行了详细的阐述。下面我将根据图片内容，为您整理并详细解释这些知识点。

---

### Java 类加载与内存分配详解 (Detailed Explanation of Java Class Loading and Memory Allocation)

本部分内容将根据您提供的图片，详细阐述 Java 程序在 JVM 中运行时的类加载机制、内存分配过程以及相关的概念。

#### 1. Java 程序执行的宏观步骤 (Macro Steps of Java Program Execution)

当执行 `Person tom = new Person(1, "tom", "男");` 这样的语句时，JVM 内部会执行以下核心步骤：

1.  **加载类 (Loading Class):**
    * JVM 会首先检查 `Person` 类是否已经被加载到内存中。如果没有，它会找到 `Person.class` 文件，并将其加载到 JVM 内存中。
    * **谁加载类？(Who loads the class?)**
        * **系统加载类 (System Class Loading):** 这是最常见的方式，由 JVM 自身的类加载器（如 Bootstrap ClassLoader, Extension ClassLoader, Application ClassLoader）自动完成。
        * **手动加载类 (Manual Class Loading):** 开发者可以通过 `ClassLoader` 类进行手动加载。例如：
            ```java
            Class c1 = null; // 类Class的对象c1
            c1 = ClassLoader.getSystemClassLoader().loadClass("Person");
            // 加载类Person，并没有初始化static变量
            ```
            **注意：** 使用 `ClassLoader.loadClass()` 加载类只会将类的字节码加载到内存中，并不会执行类的初始化（即不会执行静态变量的赋值和静态代码块）。

2.  **初始化类 (Initializing Class):**
    * 类加载完成后，如果该类是第一次被“主动使用”（例如，创建实例、访问静态变量或静态方法、反射等），JVM 会对类进行初始化。
    * **初始化过程包括：**
        * 执行类的静态变量赋值语句。
        * 执行类的静态代码块 (`static { ... }`)。
    * **未初始化类之前，类中的 `static` 变量都是默认值。例如，`school` 属性在初始化前可能是 `null`。**

3.  **调用构造方法，生成对象 (Calling Constructor, Generating Object):**
    * 类初始化完成后，JVM 会根据 `new Person(...)` 调用 `Person` 类的构造方法。
    * 构造方法负责为新创建的对象分配内存，并初始化对象的实例变量（非静态成员）。
    * 在堆 (Heap) 上为 `Person` 对象分配内存空间，并返回该对象的引用，赋给 `tom` 变量。

#### JVM 内存分配情况 (JVM Memory Allocation)

JVM 在启动时会创建多个内存区域，这些区域协同工作以支持 Java 程序的运行。主要包括：

1.  **堆 (Heap):**
    * 虚拟机管理的最大一块内存。
    * 用于存放所有对象实例和数组。
    * 是所有线程共享的区域。
    * 由垃圾回收器 (GC) 管理。

2.  **栈 (Stack):**
    * 每个线程私有的内存区域。
    * 存储局部变量、方法参数、操作数栈、方法调用信息（栈帧）。
    * 随方法进入和退出进行分配和回收。

3.  **方法区 (Method Area):**
    * 类似运行 C 语言的代码区。
    * 是所有线程共享的区域。
    * 主要存储已被 JVM 加载的类信息，包括：
        * **类结构信息：**
            * **属性 (Fields):** 例如 `public String name;`
            * **方法 (Methods):** 例如 `public void setName(String name)`
            * **类变量 (Class Variables / Static Variables):** 例如 `public static String school`
            * **常量池 (Constant Pool):** 存储字面量（如字符串常量）和符号引用。
            * **方法的字节码 (Bytecodes):** 编译后的方法指令。
        * **类对应的方法表 (Method Table for Classes):**
            * 方法表是一组对类实例方法的引用（包括从父类继承的方法）。
            * **不包含类方法 (不包含静态方法)。**
            * **每个类对应一个方法表。**

4.  **程序计数器寄存器 (Program Counter Register, PC Register):**
    * 每个线程私有的，用于存储当前线程正在执行的字节码指令的地址。

5.  **本地方法栈 (Native Stack):**
    * 每个线程私有的，用于支持 Native 方法（非 Java 语言编写的方法）的执行。

**核心观点：** 类信息（包括类的结构信息和方法表）只存在于 **方法区** 中。

#### 3. 类加载后，在内存中是如何存储的？(How are classes stored in memory after loading?)

当类被加载后，它的相关信息（元数据）会被存放在 JVM 的 **方法区**。这个过程由 **类加载子系统 (Class Loading Subsystem)** 完成。

从您提供的流程图可以看出：

* **类文件 (Class File):** 外部的 `.class` 文件是类的来源。
* **类加载子系统 (Class Loading Subsystem):** 负责将类文件加载到 JVM 内存中。
    * **加载 (Loading):** 将 `.class` 文件读取到内存中，并将其二进制数据转换为运行时数据结构，存储在方法区。
    * **卸载 (Unloading):** 当类不再被引用时，可以被卸载以释放内存（相对不常见）。
* **运行时各区域 (Runtime Data Areas):**
    * 类加载后，其结构信息、方法字节码等存储在 **方法区 (Method Area)**。
    * 当创建对象实例时，对象本身存储在 **堆 (Heap)**。
    * 方法执行时，局部变量、方法参数等存储在 **Java 栈 (Java Stack)**。
    * **寄存器 (Registers):** 图片中提到“寄存器”，在 JVM 内存模型中通常指的是程序计数器。
    * 执行引擎 (Execution Engine) 负责解释或编译执行方法区中的字节码。
    * **本地方法接口 (Native Method Interface)** 和 **本地方法库 (Native Method Library)** 用于支持 Java 代码调用非 Java 语言编写的本地方法。

#### 4. 类信息与方法表 (Class Information and Method Table)

从示意图 `Person类信息` 和 `Person类的方法表` 可以更直观地理解方法区中存储的内容：

* **`Person` 类信息 (Class Information):**
    * 包含类的名称 (`Person`)。
    * 属性 (`-No: int`, `-name: String`, `-sex: String`, `+school: String`)。
    * 构造方法 (`+person(No:int,name:String,sex:String)` )。
    * 实例方法 (`+setName(name:String):void`, `+getName(): String`, `+setNo(No:int): void`, `+getNo(): int`, `+setSex(sex:String):void`, `+getSex(): String`, `+speak():void`)。

* **`Person` 类的方法表 (Method Table):**
    * 这是一个查找表，包含了指向 `Person` 类及其父类中所有 **实例方法** 的引用。
    * 例如，它会包含指向 `Person` 类的构造方法、`setName` 方法、`getName` 方法等的指针。
    * **重要的说明是：它不包含类方法（静态方法）。** 静态方法直接与类关联，不依赖于对象实例，因此通常不通过方法表进行调用，而是通过类信息直接定位。

**说明：** 在未初始化类之前，类中的 `static` 变量（如 `school`）都是默认值（对于 `String` 类型是 `null`）。只有在类初始化阶段，这些静态变量才会被赋予其代码中指定的值。

#### 5. 什么时候加载类？(When are classes loaded?)

Java 类的加载通常遵循 **“按需加载 (Load-on-demand)”** 的原则，而不是一次性加载所有类。这意味着类只在首次“主动使用”时才会被加载。

常见的“按需加载”触发条件包括：

1.  **实例化该类的对象 (Instantiating an object of the class):**
    * 例如：`Person tom = new Person(1, "tom", "男");`
    * 当执行 `new` 关键字创建对象时，如果 `Person` 类尚未加载和初始化，JVM 会首先进行这些操作。

2.  **引用类的 `static` 成员 (Referencing a static member of the class):**
    * 例如：`System.out.println(Person.school);`
    * 当第一次访问 `Person` 类的静态变量 `school` 时，如果 `Person` 类尚未加载和初始化，JVM 会触发其加载和初始化过程。

##  类初始化

根据Java虚拟机规范，每个类或接口**被首次主动使用**时才初始化。（仅初始化一次）

主动使用有以下6种：

1.  **创建类的实例**
2.  **访问某个类或者接口的静态变量**，或者对该静态变量赋值。
    （但访问类常量不会导致类的初始化）
3.  **调用类的静态方法**
4.  **反射** (`Class.forName(xxx.xxx.xxx)`)
5.  **初始化一个类的子类**（相当于对父类的主动使用），不过直接通过子类引用父类元素，不会引起子类的初始化。
6.  Java虚拟机被标明为**启动类的类**（包含`main`方法）

### 如何初始化类？

1.  **给类变量赋初始值**
2.  **执行类块**。（在C语言块的基础上加`static`）

    ```java
    static {
        System.out.println("hello");
    }
    ```
## Java 对象生成时的内存分配细致讲解

当您在 Java 中使用 `new` 关键字创建一个对象时，Java 虚拟机（JVM）会执行一系列操作来分配内存并初始化该对象。这个过程主要涉及**堆（Heap）**、**栈（Stack）**和**方法区（Method Area）**（在 JDK 8 及之后，方法区被**元空间 MetaSpace** 取代，但概念上仍负责类信息存储）。

根据您提供的图片内容，Java 中调用构造方法生成对象的主要步骤是：

1.  在**堆**中分配空间给该对象。
2.  初始化实例变量，执行实例块。
3.  调用构造方法，生成对象，并由**引用**指向该对象。

现在我们来详细讲解这些步骤中涉及的内存分配。

### 1. 检查类是否已加载、链接、初始化

在真正分配内存之前，JVM 会首先检查该对象所属的类是否已经被加载、链接和初始化。

* **加载（Loading）**: JVM 通过类加载器查找并加载类的二进制数据（`.class` 文件）。
* **链接（Linking）**:
    * **验证（Verification）**: 确保加载的 `.class` 文件的字节码是合法的。
    * **准备（Preparation）**: 为类的**静态变量（`static` fields）**分配内存，并初始化为默认值（例如，`int` 为 `0`，`boolean` 为 `false`，引用类型为 `null`）。
        * **注意**：这里只是分配内存和设置默认值，而不是赋初始值。
    * **解析（Resolution）**: 将符号引用（symbolic references）替换为直接引用（direct references）。
* **初始化（Initialization）**: 这是类加载过程的最后一个阶段。在这个阶段，JVM 会执行类的初始化代码，包括：
    * 执行静态变量的赋值语句。
    * 执行静态代码块（`static {}`）。
    * 如果父类还没有初始化，会先初始化父类。

只有当类已经被加载、链接和初始化之后，才能进行对象的实例化。

### 2. 在堆（Heap）中分配内存

这是对象生成过程中最重要的内存分配环节。

* **内存分配方式**: JVM 会在堆内存中为新创建的对象分配一块足够大的空间。堆是所有线程共享的内存区域，也是垃圾回收的主要目标区域。
    * **指针碰撞（Pointer Bump）**: 如果堆内存是规整的（即所有已分配的内存都排列在一边，空闲内存排列在另一边），那么分配内存非常简单：只需移动一个指向空闲内存起始位置的指针，并更新其值即可。这种方式效率很高。
    * **空闲列表（Free List）**: 如果堆内存不是规整的（即已分配内存和空闲内存交错分布），那么 JVM 会维护一个列表，记录哪些内存块是可用的。分配时，会从列表中找到一块足够大的内存块，并更新列表。这种方式在内存碎片化严重时效率较低。

* **并发问题**: 多个线程可能同时尝试分配内存。为了解决这个问题，JVM 通常会采用两种策略：
    * **CAS（Compare-and-Swap）**: 虚拟机通过 CAS 操作保证更新指针的原子性。
    * **TLAB（Thread Local Allocation Buffer）**: 这是 JVM 常用的一种优化。每个线程在 Java 堆中预先分配一块私有的、较小的内存区域，称为 TLAB。当线程需要分配内存时，它首先在自己的 TLAB 中分配，这样就避免了对共享堆的同步开销。只有当 TLAB 用完时，才需要从共享堆中重新分配新的 TLAB，这时才会有同步开销。

* **内存空间**: 分配的空间不仅包含对象的所有实例变量（包括从父类继承的），还包含**对象头（Object Header）**。
    * **对象头（Object Header）**:
        * **Mark Word（标记字段）**: 存储对象的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。
        * **Klass Pointer（类型指针）**: 指向该对象的类元数据（在方法区/元空间中），JVM 通过这个指针确定该对象是哪个类的实例，从而找到其方法表、父类、接口等信息。
        * **数组长度（仅限数组对象）**: 如果对象是数组，对象头中还会包含数组的长度。

### 3. 初始化实例变量并执行实例块

在堆中分配了内存后，JVM 会对新分配的对象进行初始化：

* **实例变量默认初始化**: JVM 会将对象的所有实例变量（非静态字段）初始化为它们的默认值（与静态变量在准备阶段类似）。例如，`int` 类型变量为 `0`，`boolean` 为 `false`，引用类型为 `null`。
* **实例变量显式初始化和实例块执行**: 接下来，会按照它们在类中定义的顺序，执行实例变量的显式赋值和实例代码块（`{}` 非静态代码块）。这些操作通常在构造方法调用之前执行。如果有父类，会先执行父类的实例变量初始化和实例块，然后是子类的。

### 4. 调用构造方法

这是对象初始化的最后一步，也是开发者通常能直接控制的部分。

* **执行构造方法代码**: JVM 调用对象的构造方法。构造方法中可以包含更复杂的初始化逻辑，例如为实例变量赋特定值、调用其他方法、设置对象状态等。
* **父类构造方法**: 如果子类构造方法没有显式调用父类的构造方法（`super(...)`），编译器会自动在子类构造方法的第一行插入对父类无参构造方法的调用（`super()`）。因此，总是会先执行父类的构造方法，然后才执行子类的构造方法。这个调用链会一直向上追溯到 `Object` 类。

### 5. 引用指向新生成对象

一旦对象在堆中被完全创建并初始化，JVM 会将一个**引用（Reference）**返回给调用者。

* **引用变量**: 这个引用通常存储在**栈（Stack）**中。栈内存主要用于存储局部变量（包括基本数据类型和对象的引用变量）以及方法调用的信息。
* **指针**: 引用变量本质上是一个“指针”，它存储的是新创建对象在堆内存中的地址。通过这个引用，程序才能访问和操作堆中的对象。

### 内存分配过程总结

1.  **类加载与初始化**: 如果类尚未加载、链接和初始化，JVM 会首先完成这些步骤，涉及到**方法区（元空间）**的内存分配（用于存储类元数据，如类结构、静态变量等）。
2.  **堆内存分配**: JVM 在**堆**中为新对象分配实际的内存空间，包括对象头和所有实例变量的空间。这是对象实体存在的区域。
3.  **栈内存分配**: 在方法执行过程中，局部变量（包括对象引用）会存储在**栈**中。这个栈上的引用变量指向堆中的对象。

通过以上步骤，一个全新的、可用的 Java 对象就被成功地创建并放置在堆内存中，并通过栈上的引用变量供程序使用。当不再有任何引用指向堆中的对象时，垃圾回收器会在适当的时候回收这块内存。

### JVM运行一个程序过程及内存分配

```java
public class TestPerson {
    public static void main(String[] args) {
        Person tom = new Person(1, "tom", "男");
        Person rose = new Person(2, "rose", "女");
        tom.speak();
        rose.speak();
    }
}
```
# 运行过程
# Running Process

1.  **加载TestPerson类到方法区，同时建立该类的方法表。**
    **Load TestPerson class into the method area, and simultaneously create the method table for this class.**

2.  **初始化TestPerson类。(給类变量赋值)**
    **Initialize TestPerson class. (Assign values to class variables)**

3.  **执行TestPerson类的main方法。**
    **Execute the main method of the TestPerson class.**

    3.1) **执行 `Person tom=new Person(1,“tom”,“男” );` 语句**
        **Execute `Person tom = new Person(1, "tom", "男");` statement**

        (1) **加载Person类到方法区，同时建立该类的方法表。**
            **Load Person class into the method area, and simultaneously create the method table for this class.**

        (2) **初始化Person类。(給类变量赋值)**
            **Initialize Person class. (Assign values to class variables)**

        (3) **在堆中分配空间給Person对象。**
            **Allocate space for the Person object in the heap.**

        (4) **初始化Person对象的实例变量, 执行实例块。**
            **Initialize the instance variables of the Person object, execute instance block.**

        (5) **调构造方法。Person对象生成，并由tom引用指向该对象。**
            **Call the constructor. Person object is created, and the `tom` reference points to this object.**

    3.2 )  **执行 `Person rose=new Person(2,"rose","女" );` 语句**
        **Execute `Person rose = new Person(2, "rose", "女");` statement**

        (1) **在堆中分配空间給Person对象。**
            **Allocate space for the Person object in the heap.**

        (2) **初始化Person对象的实例变量, 执行实例块。**
            **Initialize the instance variables of the Person object, execute instance block.**

        (3) **调构造方法。Person对象生成，并由rose引用指向该对象。**
            **Call the constructor. Person object is created, and the `rose` reference points to this object.**

    3.3 ) **执行 `tom.speak();`**
        **Execute `tom.speak();`**

    3.4) **执行 `rose.speak();`**
        **Execute `rose.speak();`**

```java
public class TestPerson2 {
    public static void f1() {
        Person tom = new Person(1, "tom", "男");
        tom.school = "FUDAN";
        tom.speak();
    }

    public static void f2() {
        Person rose = new Person(2, "rose", "女");
        rose.speak();
    }

    public static void main(String[] args) {
        f1();
        f2();
    }
}
```
# 运行过程
# Running Process

1.  **加载TestPerson2类到方法区，同时建立该类的方法表。**
    **Load TestPerson2 class into the method area, and simultaneously create the method table for this class.**

2.  **初始化TestPerson2类。(給类变量赋值)**
    **Initialize TestPerson2 class. (Assign values to class variables)**

3.  **执行TestPerson2类的main方法。**
    **Execute the main method of the TestPerson2 class.**

    3.1) **执行 `f1();`**
        **Execute `f1();`**

        (1) **加载Person类到方法区，同时建立该类的方法表。**
            **Load Person class into the method area, and simultaneously create the method table for this class.**

        (2) **初始化Person类。(給类变量赋值)**
            **Initialize Person class. (Assign values to class variables)**

        (3) **在堆中分配空间給Person对象。**
            **Allocate space for the Person object in the heap.**

        (4) **初始化Person对象的实例变量, 执行实例块。**
            **Initialize the instance variables of the Person object, execute instance block.**

        (5) **调构造方法。Person对象生成，并由tom引用指向该对象。**
            **Call the constructor. Person object is created, and the `tom` reference points to this object.**

        (6) **将类Person的类变量school改为”FUDAN”。**
            **(Correction: This step seems to imply `school` is a static/class variable. However, based on the previous image `tom.school = "FUDAN";` indicates it's likely an instance variable of the `Person` object. If it were a class variable, it would typically be accessed as `Person.school`. Assuming it's an instance variable, this step means setting the `school` field of the `tom` object to "FUDAN".)**
            **Set the `school` instance variable of the `tom` object to "FUDAN".**

        (7) **执行 `speak();`**
            **Execute `speak();`**

    3.2) **执行 `f2();`**
        **Execute `f2();`**

        (1) **在堆中分配空间給Person对象。**
            **Allocate space for the Person object in the heap.**

        (2) **初始化Person对象的实例变量, 执行实例块。**
            **Initialize the instance variables of the Person object, execute instance block.**

        (3) **调构造方法。Person对象生成，并由rose引用指向该对象。**
            **Call the constructor. Person object is created, and the `rose` reference points to this object.**

        (4) **执行 `speak();`**
            **Execute `speak();`**
