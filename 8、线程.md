# 线程
## 线程
我们来详细讲解 Java 中的**线程 (Threads)**。

---

### Java 中的线程 (Threads) 详解

在计算机科学中，**线程 (Thread)** 是操作系统能够进行运算调度的最小单位。它比进程更轻量级，一个进程可以包含多个线程，这些线程共享进程的资源（如内存空间、文件句柄等），但每个线程有独立的程序计数器、栈和局部变量。

**多线程 (Multithreading)** 编程允许程序同时执行多个任务（并发），从而提高程序的响应性、吞吐量和资源利用率。Java 对多线程提供了强大的内置支持。

#### 1. 进程与线程的关系

* **进程 (Process)：** 是操作系统进行资源分配的基本单位。一个进程拥有独立的内存空间，一个程序运行起来就是一个进程。
* **线程 (Thread)：** 是操作系统进行 CPU 调度和执行的最小单位。一个进程可以包含多个线程，这些线程共享进程的资源，但拥有独立的执行路径。

**为什么需要多线程？**

1.  **提高响应性：** 例如，GUI 程序中，耗时操作在单独的线程中执行，UI 线程就不会被阻塞，界面仍然可以响应用户操作。
2.  **提高资源利用率：** 当一个任务在等待 I/O (如网络请求、文件读写) 时，CPU 可以调度其他线程执行，避免 CPU 空闲。
3.  **简化编程模型：** 将复杂任务拆分为多个独立的小任务，每个任务在自己的线程中执行，有助于模块化。
4.  **发挥多核 CPU 优势：** 在多核处理器上，不同线程可以同时在不同的 CPU 核心上运行，真正实现并行计算。

#### 2. Java 中创建线程的两种方式

Java 提供了两种主要的方式来创建和执行线程：

##### A. 继承 `java.lang.Thread` 类

* **步骤：**
    1.  创建一个类，继承 `Thread` 类。
    2.  重写 `run()` 方法，将线程要执行的任务代码放入其中。
    3.  创建该子类的实例。
    4.  调用线程实例的 `start()` 方法来启动线程。

* **示例：**

    ```java
    class MyThread extends Thread {
        private String threadName;

        public MyThread(String name) {
            this.threadName = name;
            System.out.println("Creating " + threadName);
        }

        @Override
        public void run() {
            System.out.println("Running " + threadName);
            try {
                for (int i = 0; i < 5; i++) {
                    System.out.println("Thread: " + threadName + ", " + i);
                    Thread.sleep(50); // 让线程暂停 50 毫秒
                }
            } catch (InterruptedException e) {
                System.out.println("Thread " + threadName + " interrupted.");
            }
            System.out.println("Thread " + threadName + " exiting.");
        }
    }

    public class ThreadInheritanceDemo {
        public static void main(String[] args) {
            MyThread thread1 = new MyThread("Thread-1");
            MyThread thread2 = new MyThread("Thread-2");

            thread1.start(); // 启动线程，执行 run() 方法
            thread2.start(); // 启动线程
        }
    }
    ```

* **优点：** 结构清晰，直接就是线程类。
* **缺点：** Java 是单继承的，如果你的类已经继承了其他类，就无法再继承 `Thread`。任务和线程本身紧密耦合。

##### B. 实现 `java.lang.Runnable` 接口

* **步骤：**
    1.  创建一个类，实现 `Runnable` 接口。
    2.  实现 `run()` 方法，将线程要执行的任务代码放入其中。
    3.  创建 `Runnable` 接口实现类的实例。
    4.  将 `Runnable` 实例作为参数传递给 `Thread` 类的构造器，创建 `Thread` 对象。
    5.  调用 `Thread` 对象的 `start()` 方法来启动线程。

* **示例：**

    ```java
    class MyRunnable implements Runnable {
        private String taskName;

        public MyRunnable(String name) {
            this.taskName = name;
            System.out.println("Creating task: " + taskName);
        }

        @Override
        public void run() {
            System.out.println("Executing task: " + taskName);
            try {
                for (int i = 0; i < 5; i++) {
                    System.out.println("Task: " + taskName + ", " + i);
                    Thread.sleep(50);
                }
            } catch (InterruptedException e) {
                System.out.println("Task " + taskName + " interrupted.");
            }
            System.out.println("Task " + taskName + " finished.");
        }
    }

    public class RunnableInterfaceDemo {
        public static void main(String[] args) {
            Thread thread1 = new Thread(new MyRunnable("Task-A"));
            Thread thread2 = new Thread(new MyRunnable("Task-B"));

            thread1.start();
            thread2.start();
        }
    }
    ```

* **优点：**
    * 推荐的方式。
    * **实现了任务（`Runnable`）和线程（`Thread`）的分离**，一个 `Runnable` 对象可以被多个 `Thread` 对象共享执行，更符合“单一职责原则”。
    * 你的类可以继承其他类，没有单继承的限制。
* **缺点：** 创建线程稍微复杂一些，需要多一步。

#### 3. 线程的生命周期 (Life Cycle)

一个 Java 线程在其生命周期中会经历以下几种状态：

1.  **新建 (New)：** 当你创建一个 `Thread` 对象时（例如 `new Thread()`），线程处于新建状态。此时它还没有开始执行。
2.  **可运行 (Runnable)：** 当你调用线程的 `start()` 方法时，线程进入可运行状态。此时，线程已经准备好运行，但还没有被操作系统调度执行，它正在等待 CPU。
3.  **运行 (Running)：** 线程被操作系统调度并分配到 CPU 时间片，正在执行其 `run()` 方法中的代码。
4.  **阻塞 (Blocked) / 等待 (Waiting) / 限时等待 (Timed Waiting)：** 线程在以下情况下会进入非运行状态，等待特定条件满足后才能重新进入可运行状态：
    * **阻塞 (Blocked)：** 等待获取同步锁（如 `synchronized` 块或方法）。
    * **等待 (Waiting)：** 调用 `Object.wait()`、`Thread.join()` 或 `LockSupport.park()`。它会无限期等待，直到被其他线程唤醒。
    * **限时等待 (Timed Waiting)：** 调用 `Thread.sleep(long millis)`、`Object.wait(long millis)`、`Thread.join(long millis)`、`LockSupport.parkNanos()` 或 `LockSupport.parkUntil()`。它会在指定的时间后自动唤醒。
5.  **终止 (Terminated)：** 线程的 `run()` 方法执行完毕，或者因未捕获的异常而退出。一旦线程进入终止状态，它就不能再次启动。

#### 4. 线程控制与协作

Java 提供了多种方法来控制和协作线程：

* **`start()`：** 启动线程，将其置于可运行状态。这是启动新线程的唯一方法。
* **`run()`：** 线程实际执行的任务代码。直接调用 `run()` 只是在当前线程执行任务，不会创建新线程。
* **`sleep(long millis)`：** 静态方法。让当前正在执行的线程暂停指定毫秒数，进入限时等待状态。它不会释放锁。
* **`join()` / `join(long millis)`：** 让当前线程等待另一个线程终止。
    * 例如：`thread.join();` 意味着当前线程会等待 `thread` 执行完毕后才继续执行。
* **`interrupt()`：** 向线程发送中断请求。被中断的线程可以通过检查中断状态 (`Thread.interrupted()` 或 `isInterrupted()`) 来响应中断。如果线程在 `sleep()`, `wait()`, `join()` 等方法中被中断，会抛出 `InterruptedException`。
* **`yield()`：** 静态方法。提示调度器当前线程愿意放弃当前的 CPU 时间片，让其他同样优先级的线程运行。这是一个建议，调度器不一定采纳。
* **优先级：** `setPriority(int newPriority)` 和 `getPriority()`。Java 线程优先级是 1 到 10，默认是 5。但线程优先级高度依赖操作系统实现，并不能保证精确的调度顺序。

#### 5. 线程同步 (Synchronization) 与线程安全 (Thread Safety)

当多个线程访问和修改共享资源时，可能会出现数据不一致的问题，这就是**线程不安全**。为了避免这种情况，需要使用**同步机制**来保证同一时间只有一个线程访问共享资源。

##### A. `synchronized` 关键字

* **`synchronized` 方法：** 对整个方法进行同步。对于实例方法，锁是该实例对象；对于静态方法，锁是该类的 Class 对象。
* **`synchronized` 块：** 对指定的代码块进行同步。你需要指定一个对象作为锁。

    ```java
    class Counter {
        private int count = 0;

        // synchronized 方法
        public synchronized void increment() {
            count++;
        }

        // synchronized 块
        public void decrement() {
            synchronized (this) { // 使用当前对象作为锁
                count--;
            }
        }

        public int getCount() {
            return count;
        }
    }
    ```

##### B. `java.util.concurrent.locks.Lock` 接口

* 比 `synchronized` 更灵活、功能更强大的锁机制。
* 常用实现类：`ReentrantLock`。
* 可以实现更细粒度的控制，如尝试获取锁 (`tryLock()`)、可中断地获取锁 (`lockInterruptibly()`)、公平锁等。

    ```java
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;

    class CounterWithLock {
        private int count = 0;
        private final Lock lock = new ReentrantLock();

        public void increment() {
            lock.lock(); // 获取锁
            try {
                count++;
            } finally {
                lock.unlock(); // 确保在任何情况下都释放锁
            }
        }

        public int getCount() {
            return count;
        }
    }
    ```

##### C. `volatile` 关键字

* 确保变量的可见性：当一个变量被 `volatile` 修饰时，对它的写操作会立即刷新到主内存，对它的读操作会从主内存中重新加载。
* 不保证原子性：`volatile` 不能替代 `synchronized` 来解决复合操作的原子性问题（如 `i++`）。

#### 6. 线程池 (Thread Pool)

* `java.util.concurrent.ExecutorService` 和 `Executors` 工厂类。
* 管理和复用线程的机制，避免了频繁创建和销毁线程的开销。
* 提高资源利用率和系统稳定性。

    ```java
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;

    public class ThreadPoolDemo {
        public static void main(String[] args) {
            // 创建一个固定大小的线程池，包含 3 个线程
            ExecutorService executor = Executors.newFixedThreadPool(3);

            for (int i = 0; i < 10; i++) {
                final int taskId = i;
                executor.submit(() -> { // 提交任务到线程池
                    System.out.println("Executing task " + taskId + " by " + Thread.currentThread().getName());
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
            }

            executor.shutdown(); // 关闭线程池，不再接受新任务，等待已提交任务完成
            System.out.println("Tasks submitted. Shutting down executor.");
        }
    }
    ```

#### 7. 死锁 (Deadlock)

* 多线程编程中的一个常见问题。当两个或多个线程在互相等待对方释放资源时，它们会陷入无限期的等待，导致程序停滞。
* 死锁发生的四个必要条件：
    1.  **互斥条件：** 资源不能共享，只能被一个线程占用。
    2.  **请求与保持条件：** 线程已持有至少一个资源，但又请求新的资源，同时不释放已持有的资源。
    3.  **不剥夺条件：** 资源只能由持有它的线程自愿释放，不能被其他线程强制剥夺。
    4.  **循环等待条件：** 线程之间形成一个循环，每个线程都在等待这个循环中的下一个线程所持有的资源。

#### 总结

Java 中的线程和多线程编程是一个复杂但强大的领域。理解线程的创建方式、生命周期、同步机制（`synchronized`, `Lock`）、线程池以及常见的并发问题（如死锁），对于编写高效、稳定、响应式的 Java 应用程序至关重要。并发编程是 Java 工程师必须掌握的核心技能之一。
## 主线程
我们来详细讲解 Java 中的**主线程 (Main Thread)**。

---

### Java 中的主线程 (Main Thread) 详解

在 Java 应用程序中，**主线程 (Main Thread)** 是程序执行的起点，也是所有其他线程的“祖先”线程。当你通过 `java YourProgram` 命令运行一个 Java 程序时，JVM（Java 虚拟机）会启动，并自动创建一个特殊的线程来执行你的 `public static void main(String[] args)` 方法。这个特殊的线程就是主线程。

#### 1. 主线程的地位和作用

1.  **程序的入口点：** 任何 Java 应用程序的执行都是从 `main()` 方法开始的，而执行 `main()` 方法的正是主线程。
2.  **所有其他线程的启动者：** 在 `main()` 方法中，你可以创建并启动新的线程（通过调用 `Thread` 对象的 `start()` 方法）。这些新创建的线程是主线程的“子线程”。
3.  **共享资源：** 主线程与其他自定义线程一样，可以访问和操作共享资源。
4.  **默认线程：** 如果你的程序没有显式地创建任何其他线程，那么整个程序就只由主线程一个线程来执行。
5.  **生命周期：** 主线程的生命周期与整个应用程序的生命周期紧密相关。当 `main()` 方法执行完毕，或者所有非守护线程（包括主线程自身）都终止时，JVM 就会退出。

#### 2. 主线程的特点

* **唯一性：** 一个 Java 应用程序通常只有一个主线程。
* **默认优先级：** 主线程的默认优先级是 `Thread.NORM_PRIORITY` (通常是 5)。
* **非守护线程：** 默认情况下，主线程是一个**非守护线程 (non-daemon thread)**。这意味着只要主线程还在运行，JVM 就不会退出，即使所有其他用户线程（非守护线程）都已完成。只有当所有非守护线程都终止时，JVM 才会退出。
* **可以通过 `Thread.currentThread()` 获取：** 在任何线程的代码中，你都可以通过 `Thread.currentThread()` 方法获取当前正在执行的线程的引用，如果是在 `main()` 方法中调用，它会返回主线程的引用。

#### 3. 主线程的常用操作

你可以在 `main()` 方法中像操作其他线程一样操作主线程：

* **获取信息：**
    * `Thread.currentThread().getName()`：获取主线程的名称（通常是 "main"）。
    * `Thread.currentThread().getId()`：获取主线程的唯一 ID。
    * `Thread.currentThread().getPriority()`：获取主线程的优先级。
    * `Thread.currentThread().getState()`：获取主线程的当前状态。
* **控制：**
    * `Thread.sleep(long millis)`：让主线程暂停执行一段时间。
    * `thread.join()`：让主线程等待其他子线程执行完毕。

#### 4. 主线程在多线程应用中的作用

在多线程应用程序中，主线程通常扮演以下角色：

* **初始化和设置：** 执行程序的初始化工作，如加载配置、创建数据结构等。
* **启动子线程：** 创建并调用子线程的 `start()` 方法，将耗时的任务分配给它们。
* **等待子线程完成 (可选)：** 如果主线程需要等待某些子线程的结果才能继续或结束，它可以使用 `join()` 方法等待子线程。
* **资源管理：** 负责一些全局资源的管理和清理工作（如果不在 `finally` 或 `try-with-resources` 中处理的话）。
* **简单任务执行：** 对于不需要并发处理的简单任务，主线程可以直接执行。

#### 5. 示例：主线程与子线程的交互

```java
public class MainThreadDemo {

    public static void main(String[] args) {
        // 1. 获取主线程的引用并打印信息
        Thread mainThread = Thread.currentThread();
        System.out.println("--- 主线程信息 ---");
        System.out.println("主线程名称: " + mainThread.getName()); // 通常是 "main"
        System.out.println("主线程ID: " + mainThread.getId());
        System.out.println("主线程优先级: " + mainThread.getPriority());
        System.out.println("主线程状态: " + mainThread.getState());

        System.out.println("\n--- 主线程开始执行 ---");

        // 2. 主线程执行一些任务
        try {
            System.out.println("主线程：执行任务 A...");
            Thread.sleep(100); // 主线程暂停 100 毫秒
        } catch (InterruptedException e) {
            System.out.println("主线程被中断了。");
        }

        // 3. 主线程创建并启动一个子线程
        System.out.println("主线程：创建并启动子线程...");
        Thread childThread = new Thread(() -> { // 使用 Lambda 表达式创建匿名 Runnable
            System.out.println("  子线程 [" + Thread.currentThread().getName() + "]：开始执行。");
            try {
                for (int i = 0; i < 3; i++) {
                    System.out.println("  子线程 [" + Thread.currentThread().getName() + "]：工作 " + i);
                    Thread.sleep(200);
                }
            } catch (InterruptedException e) {
                System.out.println("  子线程 [" + Thread.currentThread().getName() + "] 被中断。");
            }
            System.out.println("  子线程 [" + Thread.currentThread().getName() + "]：执行完毕。");
        }, "MyChildThread"); // 为子线程命名

        childThread.start(); // 启动子线程

        // 4. 主线程继续执行其他任务
        System.out.println("主线程：继续执行任务 B...");
        try {
            Thread.sleep(150); // 让主线程和子线程交替执行
        } catch (InterruptedException e) {
            System.out.println("主线程被中断了。");
        }

        // 5. 主线程等待子线程执行完毕（使用 join() 方法）
        try {
            System.out.println("主线程：等待子线程 [" + childThread.getName() + "] 完成...");
            childThread.join(); // 主线程会在这里阻塞，直到 childThread 终止
            System.out.println("主线程：子线程 [" + childThread.getName() + "] 已完成。");
        } catch (InterruptedException e) {
            System.out.println("主线程在等待子线程时被中断。");
        }

        System.out.println("--- 主线程执行完毕，程序即将退出 ---");
    }
}
```

#### 运行这个例子，你会看到：

* 主线程的信息首先被打印。
* 主线程开始执行任务 A。
* 主线程创建并启动子线程，然后子线程会开始其工作。
* 主线程继续执行任务 B，此时主线程和子线程会交替运行。
* 主线程调用 `childThread.join()` 后会暂停，直到子线程的 `run()` 方法执行完毕。
* 子线程完成后，主线程继续执行最后的部分，然后整个程序结束。

这个示例清晰地展示了主线程作为程序的起点，如何启动子线程，以及如何利用 `join()` 方法等待子线程完成，从而协调多线程程序的执行流程。
## 创建线程
我们来详细讲解 Java 中**创建线程**的两种主要方式，并配上代码示例。

---

### Java 中创建线程的两种方式

在 Java 中，创建线程主要有两种推荐的方式。这两种方式都涉及定义线程要执行的任务，然后将其交给 `Thread` 对象来运行。

#### 方式一：继承 `java.lang.Thread` 类

**原理：**
通过继承 `Thread` 类，你创建的类本身就是一个线程。你需要在子类中重写 `run()` 方法来定义线程的执行逻辑。

**步骤：**

1.  **定义一个类，继承 `Thread`。**
    ```java
    class MyThread extends Thread {
        // ...
    }
    ```
2.  **重写 `Thread` 类的 `run()` 方法。**
    `run()` 方法是线程的执行体，所有需要在新线程中运行的代码都放在这个方法里。
    ```java
    @Override
    public void run() {
        // 线程的执行逻辑
    }
    ```
3.  **创建该子类的实例。**
    ```java
    MyThread myThreadInstance = new MyThread();
    ```
4.  **调用线程实例的 `start()` 方法来启动线程。**
    `start()` 方法会告诉 JVM 创建一个新的执行线程，然后在新线程中调用 `run()` 方法。**直接调用 `run()` 方法并不会创建新线程，而是在当前线程中执行 `run()` 方法的内容。**
    ```java
    myThreadInstance.start();
    ```

**优点：**
* 结构简单，直接就是线程类。
* 便于管理线程特有的属性和行为（例如，可以在子类中添加线程专属的成员变量和方法）。

**缺点：**
* **Java 是单继承的。** 如果你的自定义类已经继承了其他的类（Java 中类只能单继承），那么它就不能再继承 `Thread` 类了。这是这种方式最主要的限制。
* 将任务（`run()` 方法中的代码）和线程（`Thread` 类本身）紧密耦合在一起，不利于任务的复用。

**示例代码：**

```java
// 方式一：继承 Thread 类
class MyThread extends Thread {
    private String threadName; // 线程的名称，用于区分不同的线程实例

    // 构造方法，为线程设置名称
    public MyThread(String name) {
        this.threadName = name;
        System.out.println("新建线程: " + threadName);
    }

    /**
     * run() 方法是线程的执行体。
     * 当线程通过 start() 方法启动后，JVM 会自动调用此方法。
     * 所有需要在新线程中执行的代码都写在这里。
     */
    @Override
    public void run() {
        System.out.println("线程 " + threadName + " 开始运行.");
        try {
            for (int i = 0; i < 3; i++) {
                System.out.println("线程 " + threadName + " 正在执行任务，计数: " + i);
                // 让线程暂停一段时间，模拟耗时操作
                Thread.sleep(100); // sleep 方法可能抛出 InterruptedException
            }
        } catch (InterruptedException e) {
            // 当线程在睡眠或等待状态时被中断，会捕获此异常
            System.out.println("线程 " + threadName + " 被中断了.");
            // 重新设置中断状态，以便上层或后续代码能够感知到中断
            Thread.currentThread().interrupt();
        }
        System.out.println("线程 " + threadName + " 执行完毕并退出.");
    }
}

public class ThreadCreationByInheritance {
    public static void main(String[] args) {
        System.out.println("--- 方式一：通过继承 Thread 类创建线程 ---");

        // 创建 MyThread 类的实例
        MyThread thread1 = new MyThread("Thread-A");
        MyThread thread2 = new MyThread("Thread-B");

        // 调用 start() 方法来启动线程
        // start() 方法会通知 JVM 创建一个新线程来执行 MyThread 实例的 run() 方法
        thread1.start();
        thread2.start();

        // main 线程会和 thread1、thread2 并发执行
        System.out.println("主线程继续执行其他任务...");
        try {
            Thread.sleep(200); // 让主线程也暂停一下，以便观察并发效果
        } catch (InterruptedException e) {
            System.out.println("主线程被中断。");
            Thread.currentThread().interrupt();
        }
        System.out.println("主线程完成自身任务。");
    }
}
```

#### 方式二：实现 `java.lang.Runnable` 接口

**原理：**
`Runnable` 接口定义了线程要执行的任务。你创建一个类来实现 `Runnable` 接口，然后将该类的实例（作为任务）传递给 `Thread` 对象来执行。这种方式实现了**任务与线程的分离**。

**步骤：**

1.  **定义一个类，实现 `Runnable` 接口。**
    ```java
    class MyRunnable implements Runnable {
        // ...
    }
    ```
2.  **实现 `Runnable` 接口中的 `run()` 方法。**
    同样，`run()` 方法中包含线程的执行逻辑。
    ```java
    @Override
    public void run() {
        // 线程的执行逻辑
    }
    ```
3.  **创建 `Runnable` 接口实现类的实例。**
    ```java
    MyRunnable myRunnableInstance = new MyRunnable();
    ```
4.  **将 `Runnable` 实例作为参数传递给 `Thread` 类的构造器，创建 `Thread` 对象。**
    ```java
    Thread thread = new Thread(myRunnableInstance);
    ```
5.  **调用 `Thread` 对象的 `start()` 方法来启动线程。**
    ```java
    thread.start();
    ```

**优点：**
* **推荐的方式。**
* **解决了 Java 单继承的限制。** 你的类可以继承其他类，同时实现 `Runnable` 接口，从而既能拥有父类的功能，又能作为线程任务执行。
* **任务和线程分离。** 线程任务 (`Runnable` 对象) 可以被多个线程对象共享，实现代码复用。

**缺点：**
* 代码结构稍微复杂一些，需要多一步将 `Runnable` 实例包装到 `Thread` 对象中。

**示例代码：**

```java
// 方式二：实现 Runnable 接口
class MyRunnable implements Runnable {
    private String taskName; // 任务的名称

    // 构造方法，为任务设置名称
    public MyRunnable(String name) {
        this.taskName = name;
        System.out.println("新建任务: " + taskName);
    }

    /**
     * run() 方法是任务的执行体。
     * 当 Thread 对象启动后，它会在新线程中调用此方法。
     */
    @Override
    public void run() {
        System.out.println("任务 " + taskName + " 开始执行.");
        try {
            for (int i = 0; i < 3; i++) {
                System.out.println("任务 " + taskName + " 正在执行，计数: " + i);
                Thread.sleep(150); // 模拟任务耗时
            }
        } catch (InterruptedException e) {
            System.out.println("任务 " + taskName + " 被中断了.");
            Thread.currentThread().interrupt();
        }
        System.out.println("任务 " + taskName + " 执行完毕.");
    }
}

public class ThreadCreationByRunnable {
    public static void main(String[] args) {
        System.out.println("--- 方式二：通过实现 Runnable 接口创建线程 ---");

        // 创建 MyRunnable 任务实例
        MyRunnable taskA = new MyRunnable("Task-X");
        MyRunnable taskB = new MyRunnable("Task-Y");

        // 将任务实例传递给 Thread 构造器，创建 Thread 对象
        Thread threadX = new Thread(taskA);
        Thread threadY = new Thread(taskB);

        // 启动 Thread 对象
        threadX.start();
        threadY.start();

        System.out.println("主线程继续执行其他任务...");
        try {
            Thread.sleep(250); // 让主线程也暂停一下
        } catch (InterruptedException e) {
            System.out.println("主线程被中断。");
            Thread.currentThread().interrupt();
        }
        System.out.println("主线程完成自身任务。");
    }
}
```

#### 总结与推荐

* **推荐使用实现 `Runnable` 接口的方式创建线程。** 这种方式更灵活，更符合面向对象的设计原则（任务与线程分离），并且避免了 Java 单继承的限制。
* 无论是哪种方式，启动线程的关键都是调用 `Thread` 实例的 `start()` 方法。直接调用 `run()` 方法只是普通的方法调用，不会创建新线程。
* 在实际开发中，更高级的并发 API，如**线程池 (`ExecutorService`)**，是管理和复用线程的推荐方式，它们在底层也是基于 `Runnable` 或 `Callable`（带返回值任务）接口来实现的。

希望这个详细的讲解和示例能帮助你理解 Java 中创建线程的方法！
## 多线程
我们来深入探讨 Java 中的**多线程 (Multithreading)**。

---

### Java 中的多线程 (Multithreading) 详解

**多线程 (Multithreading)** 是 Java 语言的一个核心特性，它允许程序同时执行多个任务（并发），从而显著提高程序的性能、响应性和资源利用率。在现代计算机系统（特别是多核处理器）中，多线程是充分利用硬件资源、构建高性能和高并发应用的关键。

#### 1. 为什么需要多线程？

1.  **提高响应性：** 对于图形用户界面（GUI）应用程序或Web服务器，如果所有任务都在一个线程中执行，耗时操作（如文件读写、网络请求）会阻塞主线程，导致界面卡顿或服务器无响应。多线程可以将这些耗时操作放到后台线程中，主线程继续响应用户或客户端请求。
2.  **提高资源利用率：** 当一个线程因等待外部资源（如 I/O 操作）而暂时停止执行时，CPU 可以切换到另一个线程，继续执行其他任务，避免 CPU 空闲，提高效率。
3.  **发挥多核处理器优势：** 在多核 CPU 环境下，不同的线程可以真正地在不同的 CPU 核心上并行执行，从而加速程序的整体运行速度。
4.  **简化编程模型：** 复杂任务可以分解为多个相对独立的子任务，每个子任务由一个线程处理，使得代码结构更清晰、更易于管理。

#### 2. 线程与进程回顾

* **进程 (Process)：** 操作系统中资源分配的最小单位。每个进程都有独立的内存空间、文件句柄等资源。进程之间通信成本高。
* **线程 (Thread)：** 操作系统中 CPU 调度的最小单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和大部分资源，但每个线程有独立的程序计数器、栈和局部变量。线程之间通信成本低。

#### 3. Java 中多线程的实现

Java 提供了强大的内置支持来创建和管理线程。

##### A. 创建线程的两种基本方式

1.  **继承 `java.lang.Thread` 类：**
    * 创建一个类，继承 `Thread`。
    * 重写 `run()` 方法，定义线程要执行的任务。
    * 创建子类实例，调用 `start()` 方法启动线程。
    * **优点：** 简单直观。
    * **缺点：** Java 单继承限制；任务与线程耦合。

2.  **实现 `java.lang.Runnable` 接口：**
    * 创建一个类，实现 `Runnable` 接口。
    * 实现 `run()` 方法，定义线程要执行的任务。
    * 创建 `Runnable` 实例，将其作为参数传入 `Thread` 构造器，创建 `Thread` 对象。
    * 调用 `Thread` 对象的 `start()` 方法启动线程。
    * **优点：** **推荐方式**；解耦任务与线程；避免单继承限制。
    * **缺点：** 稍微多一步封装。

##### B. 启动线程：`start()` vs `run()`

* **`start()` 方法：** **用于启动新线程。** 它会通知 JVM 创建一个新线程，并安排该新线程执行其 `run()` 方法。`start()` 方法会立即返回，而新线程则在后台并发执行。
* **`run()` 方法：** 仅仅是线程的执行体。**直接调用 `run()` 方法不会创建新线程**，而是在当前线程中同步执行 `run()` 方法内的代码，就像调用普通方法一样。

#### 4. 线程的生命周期

一个 Java 线程会经历以下状态：

1.  **新建 (New)：** `new Thread()`
2.  **可运行 (Runnable)：** `thread.start()`。线程已准备好运行，等待 CPU 调度。
3.  **运行 (Running)：** 线程正在占用 CPU 执行。
4.  **阻塞 (Blocked)：** 等待获取同步锁。
5.  **等待 (Waiting)：** 调用 `Object.wait()`, `Thread.join()`, `LockSupport.park()`。无限期等待。
6.  **限时等待 (Timed Waiting)：** 调用 `Thread.sleep(long)`, `Object.wait(long)`, `Thread.join(long)`。有时限的等待。
7.  **终止 (Terminated)：** `run()` 方法执行完毕或异常退出。线程生命周期结束，不能再次启动。

#### 5. 线程同步 (Synchronization) 与线程安全 (Thread Safety)

**线程安全问题：** 当多个线程同时访问和修改共享资源（如共享变量、集合、文件）时，由于线程执行的随机性和交错性，可能导致数据不一致、程序崩溃等问题。这被称为**线程不安全**。

**线程同步：** 解决线程安全问题的关键。它是一种协调多个线程访问共享资源的机制，确保在任何给定时刻，只有一个线程能够执行特定的代码段（临界区），从而保证数据的一致性和正确性。

##### A. `synchronized` 关键字

* **同步方法：** `public synchronized void method() { ... }`
    * 对于实例方法，锁是方法所在的对象实例 (`this`)。
    * 对于静态方法，锁是该类的 Class 对象 (`类名.class`)。
* **同步块：** `synchronized (lockObject) { ... }`
    * 需要指定一个对象作为锁 (`lockObject`)。任何对象都可以作为锁。

**特点：**
* **互斥性：** 保证同一时间只有一个线程执行被同步的代码。
* **可见性：** `synchronized` 块或方法的进入/退出会强制刷新主内存中的变量，确保线程看到最新值。
* **重入性：** 同一个线程可以多次获得同一个锁。

##### B. `java.util.concurrent.locks.Lock` 接口

* 比 `synchronized` 更灵活的显式锁机制。
* **常用实现：** `ReentrantLock`。
* **特点：**
    * **可中断：** `lockInterruptibly()` 允许在等待锁时响应中断。
    * **尝试获取锁：** `tryLock()` 不会一直阻塞。
    * **公平性：** 可以创建公平锁（按请求顺序获取），非公平锁（默认）性能更高。
    * 需要手动 `lock()` 和 `unlock()`，通常在 `finally` 块中 `unlock()` 以确保释放锁。

##### C. `volatile` 关键字

* 用于修饰变量。
* **可见性：** 确保变量的修改对所有线程立即可见。写操作会立即刷新到主内存，读操作会从主内存重新加载。
* **不保证原子性：** `volatile` 无法保证复合操作（如 `i++`）的原子性。它主要用于保证状态标志的可见性。

#### 6. 线程间通信

当线程需要协作完成任务时，它们需要进行通信。

* **`wait()`, `notify()`, `notifyAll()`：** `Object` 类的方法，必须在 `synchronized` 块/方法中调用。
    * `wait()`：释放锁，进入等待状态，直到被 `notify()` 或 `notifyAll()` 唤醒。
    * `notify()`：唤醒一个正在等待该对象锁的线程。
    * `notifyAll()`：唤醒所有正在等待该对象锁的线程。
* **`java.util.concurrent` 包中的工具：**
    * `Condition` (与 `Lock` 配合，提供更细粒度的等待/通知机制)。
    * `BlockingQueue` (阻塞队列，实现生产者-消费者模式)。
    * `CountDownLatch`, `CyclicBarrier`, `Semaphore` (用于复杂的线程协作)。

#### 7. 线程池 (Thread Pool)

* `java.util.concurrent.ExecutorService` (接口) 和 `Executors` (工厂类)。
* **目的：** 管理和复用线程。避免频繁创建和销毁线程的开销。
* **优点：** 提高性能，减少资源消耗，提供线程管理和任务调度功能。
* **常用类型：**
    * `newFixedThreadPool()`: 固定大小的线程池。
    * `newCachedThreadPool()`: 按需创建线程的缓存线程池。
    * `newSingleThreadExecutor()`: 单一线程的线程池，按顺序执行任务。

#### 8. 并发工具与高级 API (`java.util.concurrent` 包)

* **`Callable` 和 `Future`：**
    * `Callable` 接口：类似于 `Runnable`，但 `run()` 方法可以返回结果并抛出异常。
    * `Future` 接口：表示异步计算的结果。可以通过 `Future.get()` 获取 `Callable` 任务的执行结果（会阻塞直到结果可用）。
* **原子操作类：** `AtomicInteger`, `AtomicLong`, `AtomicReference` 等。
    * 提供了非阻塞的原子操作，通过 CAS (Compare-And-Swap) 算法保证操作的原子性，比 `synchronized` 性能更高。
* **并发集合：** `ConcurrentHashMap`, `CopyOnWriteArrayList`, `CopyOnWriteArraySet` 等。
    * 在多线程环境下提供高性能和线程安全的数据结构。

#### 9. 死锁 (Deadlock)

* 多线程编程中的一个严重问题，指两个或多个线程在互相等待对方释放资源时，都陷入无限期的等待，导致程序停滞。
* **死锁发生的四个必要条件：** 互斥、请求与保持、不剥夺、循环等待。
* **避免死锁的策略：** 破坏其中一个或多个条件，例如：
    * 加锁顺序一致性。
    * 限制获取锁的数量。
    * 使用 `tryLock()` 避免死锁。

#### 总结

Java 多线程是构建高性能、高并发、高响应性应用程序的基石。从基本的线程创建、生命周期管理，到复杂的线程同步、通信、线程池以及并发工具，Java 提供了一整套强大的 API。掌握这些概念和技术，是现代 Java 开发者的必备技能。在实际开发中，应始终优先考虑线程安全、避免死锁，并合理利用 `java.util.concurrent` 包提供的并发工具，以构建健壮可靠的多线程应用。
## 线程的启动：start（）
我们来详细讲解 Java 中**线程的启动：`start()` 方法**。

---

### Java 线程的启动：`start()` 方法详解

在 Java 中，当你创建了一个 `Thread` 对象后（无论是通过继承 `Thread` 类还是实现 `Runnable` 接口），仅仅创建对象并不会使线程开始执行。你必须显式地调用其 `start()` 方法来启动这个线程，使其进入执行状态。

`start()` 方法是 Java 多线程编程中**启动一个新线程的唯一正确方式**。

#### 1. `start()` 方法的作用

1.  **分配系统资源：** 调用 `start()` 方法后，JVM（Java 虚拟机）会向操作系统请求创建并分配一个新的线程所需的系统资源。这包括独立的调用栈（Call Stack）、程序计数器（Program Counter）等。
2.  **线程状态转换：** 将线程从**新建 (New)** 状态转换为**可运行 (Runnable)** 状态。一旦线程处于可运行状态，它就具备了被操作系统调度执行的资格。
3.  **调用 `run()` 方法：** 新创建的线程会异步地、并发地开始执行其 `run()` 方法中的代码。`start()` 方法会立即返回，而 `run()` 方法则在新线程中独立运行。

#### 2. 为什么不能直接调用 `run()` 方法？

这是初学者最常犯的错误之一。直接调用线程对象的 `run()` 方法并不会启动一个新线程，而是：

* 仅仅将 `run()` 方法当作一个普通的成员方法来调用。
* `run()` 方法的代码会在**当前线程**（例如主线程）中执行。
* 不会创建新的线程。
* 不会产生并发效果。

**对比 `start()` 和直接调用 `run()`：**

| 特性           | `start()` 方法                                   | 直接调用 `run()` 方法                      |
| :------------- | :----------------------------------------------- | :----------------------------------------- |
| **是否创建新线程** | **是**，JVM 会创建一个新的操作系统线程。         | **否**，在当前线程中执行。                 |
| **是否并发执行** | **是**，`start()` 立即返回，`run()` 在新线程中并发执行。 | **否**，同步执行，`run()` 执行完后才返回。 |
| **执行位置** | 在新创建的线程中执行 `run()` 方法。              | 在调用 `run()` 方法的当前线程中执行。      |
| **多线程效果** | **实现多线程并发。** | **无多线程效果，只是普通方法调用。** |
| **线程状态** | 将线程从新建置为可运行。                         | 不改变线程状态，只是普通方法调用。         |

#### 3. 启动线程的示例

无论是继承 `Thread` 类还是实现 `Runnable` 接口，启动线程都是通过调用 `Thread` 对象的 `start()` 方法。

**示例 1：继承 `Thread` 类**

```java
class MySimpleThread extends Thread {
    @Override
    public void run() {
        System.out.println("这是一个通过继承 Thread 启动的新线程：" + Thread.currentThread().getName());
        try {
            Thread.sleep(100); // 模拟任务耗时
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("新线程 " + Thread.currentThread().getName() + " 执行完毕。");
    }
}

public class StartMethodDemo1 {
    public static void main(String[] args) {
        System.out.println("主线程开始执行。当前线程：" + Thread.currentThread().getName());

        MySimpleThread myThread = new MySimpleThread();

        // 正确启动线程：调用 start()
        myThread.start(); // JVM 创建新线程，并在其中调用 myThread.run()

        // 错误示例：如果直接调用 run()，它会在主线程中同步执行
        // myThread.run(); // 不要这样做，这只是普通方法调用，不会创建新线程

        System.out.println("主线程继续执行。当前线程：" + Thread.currentThread().getName());
        try {
            Thread.sleep(150); // 让主线程也暂停一下，以便观察并发效果
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程执行完毕。");
    }
}
```

**示例 2：实现 `Runnable` 接口**

```java
class MySimpleRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("这是一个通过实现 Runnable 启动的新线程：" + Thread.currentThread().getName());
        try {
            Thread.sleep(100); // 模拟任务耗时
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("新线程 " + Thread.currentThread().getName() + " 执行完毕。");
    }
}

public class StartMethodDemo2 {
    public static void main(String[] args) {
        System.out.println("主线程开始执行。当前线程：" + Thread.currentThread().getName());

        MySimpleRunnable myRunnable = new MySimpleRunnable();
        Thread thread = new Thread(myRunnable); // 将 Runnable 任务包装到 Thread 对象中

        // 正确启动线程：调用 Thread 对象的 start()
        thread.start(); // JVM 创建新线程，并在其中调用 myRunnable.run()

        // 错误示例：如果直接调用 run()，它会在主线程中同步执行
        // myRunnable.run(); // 同样，不要直接调用，这不是启动新线程

        System.out.println("主线程继续执行。当前线程：" + Thread.currentThread().getName());
        try {
            Thread.sleep(150); // 让主线程也暂停一下
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程执行完毕。");
    }
}
```

#### 4. `start()` 方法的注意事项

* **一个线程只能启动一次：** 一旦一个线程通过 `start()` 方法启动并进入了执行状态，它的生命周期就开始了。当 `run()` 方法执行完毕或异常退出后，线程就进入了终止状态。**尝试对一个已经启动或已经终止的线程再次调用 `start()` 方法，会抛出 `IllegalThreadStateException` 运行时异常。**
* **线程的唯一标识：** 每个通过 `start()` 启动的线程都会获得一个唯一的线程 ID。
* **并发非确定性：** 尽管你调用了 `start()`，但不能保证新线程会立即运行，也不能保证它会与主线程或任何其他线程的执行顺序。线程调度是由 JVM 和操作系统共同决定的，其执行顺序具有非确定性。

**总结：**

`start()` 方法是 Java 中多线程编程的基石。它负责为线程分配系统资源，将线程状态从新建转换为可运行，并最终在新创建的线程中异步地执行 `run()` 方法中的任务。理解 `start()` 与直接调用 `run()` 的本质区别，是正确进行多线程编程的关键。
## 使用isAlive（）和join（）
## 线程的状态
好的，我们来详细讲解 Java 中线程的 `isAlive()` 方法和 `join()` 方法，它们都与线程的生命周期和协作密切相关。

---

### Java 线程的 `isAlive()` 和 `join()` 方法详解

这两个方法都属于 `java.lang.Thread` 类，用于帮助我们管理和协调线程的执行。

#### 1. `isAlive()` 方法

* **作用：** 判断线程是否处于“存活”状态。
* **返回类型：** `boolean`
* **定义：**
    * `public final boolean isAlive()`
* **行为：** 如果线程已经启动但尚未终止（即线程处于**可运行 (Runnable)**、**运行 (Running)**、**阻塞 (Blocked)**、**等待 (Waiting)** 或**限时等待 (Timed Waiting)** 状态），`isAlive()` 方法就返回 `true`。
    * 如果线程处于**新建 (New)** 状态（即只创建了 `Thread` 对象但尚未调用 `start()`）或**终止 (Terminated)** 状态（即 `run()` 方法已执行完毕或因异常退出），`isAlive()` 方法就返回 `false`。

* **使用场景：**
    * 在启动线程后，检查线程是否已经开始运行。
    * 在等待线程结束之前，偶尔检查线程是否还在活动。
    * 但通常不建议使用 `isAlive()` 来作为线程同步或等待线程结束的精确控制手段，因为它只是一个瞬时状态的快照，无法保证后续的状态。更可靠的等待线程结束的方法是 `join()`。

* **示例：**

    ```java
    class MyAliveThread extends Thread {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " 开始运行.");
            try {
                // 模拟耗时操作
                Thread.sleep(200);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName() + " 被中断.");
            }
            System.out.println(Thread.currentThread().getName() + " 运行结束.");
        }
    }

    public class IsAliveDemo {
        public static void main(String[] args) {
            MyAliveThread thread = new MyAliveThread();

            // 1. 线程刚创建，尚未启动
            System.out.println("线程启动前 isAlive(): " + thread.isAlive()); // 输出: false

            thread.start(); // 启动线程

            // 2. 线程启动后，但在 run() 方法完成前
            System.out.println("线程启动后 immediately isAlive(): " + thread.isAlive()); // 输出: true (几乎总是)

            // 3. 稍微等待，让子线程有机会运行
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("线程运行中 isAlive(): " + thread.isAlive()); // 输出: true

            // 4. 等待线程完全结束
            try {
                thread.join(); // 等待 thread 线程终止
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // 5. 线程运行结束后
            System.out.println("线程运行结束后 isAlive(): " + thread.isAlive()); // 输出: false
        }
    }
    ```

#### 2. `join()` 方法

* **作用：** `join()` 方法用于让当前线程（调用 `join()` 方法的线程）**等待**另一个线程（被 `join()` 的线程）终止。
* **返回类型：** `void`
* **定义：**
    * `public final void join() throws InterruptedException`：无限期等待被 `join()` 的线程终止。
    * `public final synchronized void join(long millis) throws InterruptedException`：最多等待指定的毫秒数。如果超时，被 `join()` 的线程可能仍在运行，但当前线程会继续执行。
    * `public final synchronized void join(long millis, int nanos) throws InterruptedException`：更精确的等待，指定毫秒和纳秒。

* **行为：**
    * 当一个线程 A 调用另一个线程 B 的 `B.join()` 方法时，线程 A 会进入**等待 (Waiting)** 或**限时等待 (Timed Waiting)** 状态。
    * 线程 A 会一直阻塞，直到以下任一条件发生：
        1.  线程 B 终止（其 `run()` 方法执行完毕或抛出未捕获的异常）。
        2.  `join(long millis)` 方法等待时间超时。
        3.  线程 A 自身被中断（此时 `join()` 方法会抛出 `InterruptedException`）。

* **使用场景：**
    * **任务依赖：** 当主线程需要等待子线程完成某些计算或数据处理，才能继续执行后续操作时。
    * **资源汇总：** 例如，多个线程并行计算不同部分，主线程等待所有计算完成，然后汇总结果。
    * **确保顺序：** 尽管多线程强调并发，但在某些特定业务逻辑中，可能需要确保某个线程在另一个线程之后完成。

* **示例：**

    ```java
    class DataProcessorThread extends Thread {
        private String data;
        private int result;

        public DataProcessorThread(String name, String data) {
            super(name);
            this.data = data;
        }

        @Override
        public void run() {
            System.out.println(getName() + " 开始处理数据: " + data);
            try {
                // 模拟数据处理，例如计算数据长度的平方
                int processedValue = data.length() * data.length();
                Thread.sleep(1000); // 模拟耗时 1 秒
                result = processedValue;
                System.out.println(getName() + " 数据处理完成，结果: " + result);
            } catch (InterruptedException e) {
                System.out.println(getName() + " 数据处理被中断.");
                Thread.currentThread().interrupt(); // 重新设置中断状态
            }
        }

        public int getResult() {
            return result;
        }
    }

    public class JoinDemo {
        public static void main(String[] args) {
            System.out.println("主线程开始.");

            DataProcessorThread processor1 = new DataProcessorThread("Processor-1", "Hello World");
            DataProcessorThread processor2 = new DataProcessorThread("Processor-2", "Java Programming");

            processor1.start(); // 启动数据处理器 1
            processor2.start(); // 启动数据处理器 2

            // 主线程需要等待两个处理器线程完成它们的计算，才能获取结果
            try {
                System.out.println("主线程等待 Processor-1 完成...");
                processor1.join(); // 主线程在这里阻塞，直到 processor1 终止
                System.out.println("主线程等待 Processor-2 完成...");
                processor2.join(); // 主线程在这里阻塞，直到 processor2 终止
            } catch (InterruptedException e) {
                System.out.println("主线程在等待子线程时被中断.");
                Thread.currentThread().interrupt();
            }

            // 所有处理器线程都已完成，主线程可以安全地获取结果
            System.out.println("主线程获取 Processor-1 的结果: " + processor1.getResult());
            System.out.println("主线程获取 Processor-2 的结果: " + processor2.getResult());

            System.out.println("主线程结束.");
        }
    }
    ```

#### 3. `isAlive()` 和 `join()` 的关系与区别

* `isAlive()` 只是一个状态查询，它告诉你线程当前是否正在运行（或准备运行）。它**不能保证**线程在调用 `isAlive()` 之后的一瞬间仍然存活或终止。
* `join()` 是一个**同步机制**。它会使当前线程阻塞，直到被 `join()` 的线程真正终止。它提供了比 `isAlive()` 更强大的线程协作和等待能力。

**总结：**

* 使用 `isAlive()` 可以在不阻塞当前线程的情况下，快速检查另一个线程的生存状态。
* 使用 `join()` 则可以确保当前线程在继续执行之前，先等待目标线程完成其任务。在多线程协作中，`join()` 是一个非常重要的工具，用于管理线程之间的依赖关系和保证任务的顺序执行。
## 线程的调度
好的，我们来详细讲解 Java 中**线程的调度 (Thread Scheduling)**。

---

### Java 线程的调度 (Thread Scheduling) 详解

**线程调度**是指操作系统（或 JVM 中的线程调度器）决定在多线程程序中，哪一个线程在何时、以何种顺序获得 CPU 资源（执行时间片）来执行的过程。由于 CPU 在某一时刻只能执行一个线程的指令，因此线程调度是实现多任务并发的关键。

Java 线程调度是**抢占式 (Preemptive)** 和**基于优先级 (Priority-based)** 调度的结合。

#### 1. 线程调度的基本概念

1.  **并发 (Concurrency) vs 并行 (Parallelism)：**
    * **并发：** 指的是逻辑上的同时进行。在单核 CPU 上，通过快速切换线程（分时复用）来实现并发，看起来就像多个任务在同时执行。
    * **并行：** 指的是物理上的同时进行。在多核 CPU 上，不同的线程可以在不同的 CPU 核心上同时执行，实现真正的并行计算。

2.  **时间片 (Time Slice / Quantum)：**
    * CPU 分配给每个线程的短暂执行时间。当一个线程的时间片用完后，操作系统会进行上下文切换 (Context Switch)，将 CPU 分配给另一个线程。

3.  **上下文切换 (Context Switch)：**
    * 操作系统保存当前正在执行线程的 CPU 状态（寄存器、程序计数器等），然后加载即将执行线程的 CPU 状态的过程。上下文切换会带来一定的性能开销。

4.  **抢占式调度 (Preemptive Scheduling)：**
    * 现代操作系统大多采用抢占式调度。这意味着操作系统可以根据优先级、时间片等因素，强制中断（抢占）当前正在运行的线程，将 CPU 分配给另一个更高优先级或等待时间更长的线程。线程本身无法控制何时被中断。
    * 与此相对的是**协作式调度 (Cooperative Scheduling)**，在这种模式下，线程只有在主动放弃 CPU（如调用 `yield()` 或进入等待状态）时，才会切换到其他线程。协作式调度容易导致高优先级任务长时间无法执行（如果某个线程长时间不放弃 CPU）。

#### 2. Java 线程调度器的工作原理

Java 线程调度器是 JVM 的一部分，它负责管理 Java 线程的生命周期和执行。它依赖于底层操作系统的线程调度机制。

1.  **优先级 (Priority)：**
    * 每个 Java 线程都有一个优先级，范围从 `Thread.MIN_PRIORITY` (1) 到 `Thread.MAX_PRIORITY` (10)，默认是 `Thread.NORM_PRIORITY` (5)。
    * **高优先级的线程有更大的机会获得 CPU 执行时间。** 当有多个线程处于可运行状态时，调度器倾向于选择优先级最高的线程来运行。
    * **局限性：** 线程优先级是 JVM 对操作系统调度器的一个**建议**。实际的调度行为高度依赖于底层操作系统的实现。不同的操作系统对线程优先级的处理可能不同（例如，Windows 是 32 级优先级，Linux 默认没有严格的优先级，但可以通过 Nice 值影响调度）。因此，**不要过度依赖线程优先级来保证程序的正确性或严格的执行顺序**，它更多地用于性能优化或提供提示。

2.  **时间片轮转 (Time Slicing)：**
    * 当多个同等优先级的线程处于可运行状态时，调度器会采用时间片轮转的方式，为每个线程分配一个短暂的 CPU 时间片，然后进行切换，使得所有线程都有机会运行，避免“饿死”。
    * Java 规范没有明确规定时间片的大小，这取决于 JVM 实现和操作系统。

#### 3. 影响线程调度的因素（线程状态转换）

线程在执行过程中会因为各种操作而放弃 CPU 或被调度：

1.  **`yield()` 方法：**
    * `public static native void yield();`
    * 这是一个静态方法，调用它的线程会**提示**调度器：它愿意放弃当前 CPU 时间片，让其他同等优先级的线程有机会运行。
    * **它是对调度器的一个建议，不保证一定发生线程切换。** 调度器可能会忽略这个提示，也可能将 CPU 再次分配给调用 `yield()` 的线程。
    * **不释放锁。**

2.  **`sleep(long millis)` 方法：**
    * `public static native void sleep(long millis) throws InterruptedException;`
    * 这是一个静态方法，调用它的线程会**主动休眠**指定毫秒数，进入**限时等待 (Timed Waiting)** 状态。
    * 线程在睡眠期间不会被调度执行。
    * **它会释放 CPU，但不释放锁。**
    * 时间到期后，线程进入可运行状态，等待调度。
    * 如果线程在睡眠期间被中断，会抛出 `InterruptedException`。

3.  **`join()` 方法：**
    * `public final void join() throws InterruptedException;`
    * 调用 `thread.join()` 的线程会**阻塞**，进入**等待 (Waiting)** 状态，直到 `thread` 线程终止。
    * **它会释放 CPU，但不释放锁。**

4.  **`wait()` / `notify()` / `notifyAll()` 方法：**
    * `public final native void wait() throws InterruptedException;`
    * `public final native void notify();`
    * `public final native void notifyAll();`
    * 这些方法是 `Object` 类的，必须在**同步块或同步方法内部**调用。
    * `wait()`：调用线程会**释放对象锁**，进入**等待 (Waiting)** 状态，直到被其他线程的 `notify()` 或 `notifyAll()` 唤醒，或被中断。
    * `notify()` / `notifyAll()`：唤醒正在等待该对象锁的一个/所有线程，但**不释放锁**。被唤醒的线程需要重新竞争锁才能执行。

5.  **I/O 操作：**
    * 当线程执行文件读写、网络通信等 I/O 操作时，由于这些操作通常涉及等待外部设备，线程会进入**阻塞 (Blocked)** 状态，暂时放弃 CPU。I/O 完成后，线程重新进入可运行状态。

6.  **同步锁竞争：**
    * 当线程尝试获取一个被其他线程持有的 `synchronized` 锁或 `Lock` 锁时，它会进入**阻塞 (Blocked)** 状态，直到锁被释放并被其获取。

7.  **时间片耗尽：**
    * 在抢占式调度下，即使线程没有主动放弃 CPU，当其时间片用完后，操作系统也会强制将其从运行状态切换到可运行状态，将 CPU 分配给其他线程。

#### 4. 线程调度器的行为特点

* **非确定性：** 除了严格的同步机制（如 `synchronized` 和 `Lock`），线程的实际执行顺序和何时切换是**非确定性**的。你不能依赖于特定顺序的执行来保证程序的正确性。
* **公平性与非公平性：**
    * **非公平调度：** 调度器可能更倾向于让刚释放 CPU 的线程或刚被唤醒的线程立即再次获得 CPU，而不管其他线程等待了多久。大多数 JVM 默认采用非公平调度，因为它上下文切换开销小，吞吐量高。
    * **公平调度：** 调度器会尽量保证等待时间最长的线程优先获得 CPU。`ReentrantLock` 可以构造为公平锁。公平调度通常会带来更高的上下文切换开销和更低的吞吐量。
* **守护线程 (Daemon Threads)：** 守护线程的生命周期与非守护线程（用户线程）无关。如果 JVM 中只剩下守护线程，JVM 就会退出，而不管守护线程是否还在运行。这在日志记录、垃圾回收等后台任务中很有用。

#### 5. 线程调度对性能的影响

* **上下文切换开销：** 频繁的上下文切换会消耗 CPU 时间，降低程序性能。
* **缓存失效：** 上下文切换可能导致 CPU 缓存中的数据失效，降低缓存命中率。
* **同步开销：** 锁机制会引入额外的开销，可能导致性能下降。

#### 总结

Java 的线程调度是 JVM 和底层操作系统协同工作的结果。它主要基于**优先级**和**抢占式**的时间片轮转。开发者可以通过 `sleep()`, `wait()`, `notify()`, `join()`, `yield()` 以及同步机制（`synchronized`, `Lock`）来影响和协调线程的执行，但需要记住，**线程的实际执行顺序是高度非确定性的**。在多线程编程中，确保程序的正确性应依赖于可靠的同步机制，而非对线程调度顺序的假设。理解线程调度有助于编写更高性能、更稳定的并发应用程序。
## 线程间的同步
好的，我们来详细讲解 Java 中**线程间的同步 (Synchronization between Threads)**。

---

### Java 线程间的同步 (Synchronization) 详解

在多线程编程中，**线程同步**是指协调多个线程，以确保它们在访问和修改共享资源（如共享变量、数据结构、文件等）时，能够按照预期的顺序和方式进行，从而避免数据不一致、状态混乱或程序崩溃等问题。当多个线程同时访问和修改同一份共享资源时，如果缺乏同步机制，就会出现**线程不安全 (Thread Unsafe)** 的情况，导致竞态条件 (Race Condition)。

**竞态条件 (Race Condition)：** 指多个线程竞相访问和修改共享资源，但最终结果取决于线程执行的相对时序，导致结果不确定或不正确。

**线程安全 (Thread Safety)：** 指在多线程环境下，一个类或方法在被多个线程同时访问时，仍能表现出正确的行为，且不依赖于操作系统的调度方式。

#### 1. 为什么需要线程同步？

考虑一个简单的例子：一个计数器 `count`，多个线程同时对其执行 `count++` 操作。
`count++` 实际上是一个复合操作，包含三个步骤：
1.  读取 `count` 的当前值。
2.  将 `count` 的值加 1。
3.  将新值写回 `count`。

如果线程 A 读取 `count` (假设为 0)，线程 B 也在几乎同时读取 `count` (也为 0)。然后线程 A 将 `count` 增加到 1 并写回，接着线程 B 也将 `count` 增加到 1 并写回。最终 `count` 的值是 1，而不是预期的 2。这就是一个典型的竞态条件导致的数据不一致问题。

线程同步的目的就是为了解决这类问题，确保对共享资源的访问是**原子性 (Atomicity)**、**可见性 (Visibility)** 和**有序性 (Ordering)** 的。

#### 2. Java 中实现线程同步的几种主要方式

Java 提供了多种线程同步机制，从语言内置的关键字到 `java.util.concurrent` 包中的高级工具。

##### A. `synchronized` 关键字 (最常用和基础)

`synchronized` 关键字是 Java 提供的一种内置的同步机制，它用于确保在任何给定时刻，只有一个线程可以执行被 `synchronized` 保护的代码块或方法。

* **互斥性 (Mutual Exclusion)：** `synchronized` 保证同一时间只有一个线程可以持有锁并进入临界区。
* **可见性 (Visibility)：** `synchronized` 块的进入和退出会强制刷新主内存中的变量，确保线程看到最新值。
* **重入性 (Reentrancy)：** 同一个线程可以多次获得同一个锁。

**用法：**

1.  **同步方法 (Synchronized Methods)：**
    * **实例方法：** `public synchronized void increment() { count++; }`
        * 锁对象：该方法所属的**当前实例对象 (`this`)**。
        * 作用范围：整个方法体。
    * **静态方法：** `public static synchronized void staticIncrement() { staticCount++; }`
        * 锁对象：该方法所属类的 `Class` 对象 (`类名.class`)。
        * 作用范围：整个静态方法体。

2.  **同步块 (Synchronized Blocks)：**
    * `synchronized (lockObject) { /* 临界区代码 */ }`
    * `lockObject`：任何 Java 对象都可以作为锁对象。
    * **选择锁对象：**
        * 对于**实例**共享数据，通常使用 `this` 或专门的 `final Object lock = new Object();` 作为锁。
        * 对于**静态**共享数据，必须使用 `类名.class` 作为锁。
    * **优点：** 可以精确控制锁的范围，只同步必要的代码，提高并发性。

**示例：**

```java
class Counter {
    private int count = 0;

    // 同步实例方法：锁是 Counter 实例本身
    public synchronized void increment() {
        count++;
        System.out.println(Thread.currentThread().getName() + " incremented to " + count);
    }

    // 同步块：锁是 Counter 实例本身 (与上面方法效果相同)
    public void decrement() {
        synchronized (this) {
            count--;
            System.out.println(Thread.currentThread().getName() + " decremented to " + count);
        }
    }

    // 获取 count，如果是共享数据，最好也同步
    public synchronized int getCount() {
        return count;
    }
}

public class SynchronizedDemo {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task, "Thread-1");
        Thread t2 = new Thread(task, "Thread-2");

        t1.start();
        t2.start();

        t1.join(); // 等待 t1 结束
        t2.join(); // 等待 t2 结束

        System.out.println("最终计数: " + counter.getCount()); // 期望是 2000
    }
}
```

##### B. `java.util.concurrent.locks.Lock` 接口 (显式锁)

`Lock` 接口及其实现（最常用的是 `ReentrantLock`）提供了比 `synchronized` 更强大、更灵活的锁机制。

**特点：**

* **显式获取与释放：** 需要手动调用 `lock()` 方法获取锁，并在 `finally` 块中调用 `unlock()` 方法释放锁，以确保锁总能被释放。
* **更细粒度控制：**
    * **可中断锁：** `lockInterruptibly()` 允许线程在等待锁时响应中断。
    * **尝试获取锁：** `tryLock()` 可以尝试获取锁而不会一直阻塞，可以带超时参数。
    * **公平性：** `ReentrantLock` 可以构造为公平锁（按请求顺序获取），`synchronized` 默认是非公平锁。
* **条件变量：** 配合 `Condition` 接口（通过 `Lock` 对象的 `newCondition()` 方法创建），可以实现更灵活的线程间通信（`await()` 替代 `wait()`，`signal()` 替代 `notify()`）。

**示例 (`ReentrantLock`)：**

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class CounterWithLock {
    private int count = 0;
    private final Lock lock = new ReentrantLock(); // 创建一个可重入锁

    public void increment() {
        lock.lock(); // 显式获取锁
        try {
            count++;
            System.out.println(Thread.currentThread().getName() + " incremented to " + count);
        } finally {
            lock.unlock(); // 显式释放锁，必须在 finally 中确保释放
        }
    }

    public int getCount() {
        return count; // 对于简单的读取，如果保证写操作已同步且可见性，有时可以不加锁
    }
}

public class ReentrantLockDemo {
    public static void main(String[] args) throws InterruptedException {
        CounterWithLock counter = new CounterWithLock();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task, "Thread-A");
        Thread t2 = new Thread(task, "Thread-B");

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("最终计数: " + counter.getCount()); // 期望是 2000
    }
}
```

##### C. `volatile` 关键字 (保证可见性，不保证原子性)

* **作用：** `volatile` 用于修饰变量，确保该变量的修改对所有线程立即可见。
* **可见性：** 对 `volatile` 变量的写入操作会立即刷新到主内存，对 `volatile` 变量的读取操作会从主内存中重新加载最新值。
* **不保证原子性：** `volatile` 无法保证复合操作（如 `i++`）的原子性。它只能保证单个读/写操作的可见性。
* **适用场景：** 通常用于标记一个状态标志位（`boolean` 变量），当一个线程修改这个标志位后，其他线程能立即看到。

**示例：**

```java
class FlagChanger implements Runnable {
    private volatile boolean running = true; // 使用 volatile 保证可见性

    public void stopRunning() {
        running = false; // 线程 A 修改 running
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " 开始运行.");
        while (running) { // 线程 B 不断检查 running
            // 模拟工作
        }
        System.out.println(Thread.currentThread().getName() + " 停止运行.");
    }
}

public class VolatileDemo {
    public static void main(String[] args) throws InterruptedException {
        FlagChanger changer = new FlagChanger();
        Thread workerThread = new Thread(changer, "WorkerThread");

        workerThread.start();

        // 主线程等待一段时间，让 workerThread 运行
        Thread.sleep(100);

        // 主线程修改 running 标志
        System.out.println(Thread.currentThread().getName() + " 正在请求 WorkerThread 停止...");
        changer.stopRunning(); // 主线程修改 volatile 变量

        // 等待 workerThread 停止
        workerThread.join();
        System.out.println(Thread.currentThread().getName() + " 结束.");
    }
}
```

##### D. `java.util.concurrent.atomic` 包 (原子类)

* 提供了对基本数据类型和对象引用的**原子操作**。
* **无需加锁：** 底层通过 CAS (Compare-And-Swap) 等硬件指令实现，避免了传统锁的开销。
* **常用类：** `AtomicInteger`, `AtomicLong`, `AtomicBoolean`, `AtomicReference`。
* **适用场景：** 对单个变量进行原子性的递增、递减、比较并交换等操作，性能优于 `synchronized`。

**示例：**

```java
import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0); // 使用原子类

    public void increment() {
        count.incrementAndGet(); // 原子性递增并获取最新值
        System.out.println(Thread.currentThread().getName() + " incremented to " + count.get());
    }

    public int getCount() {
        return count.get();
    }
}

public class AtomicDemo {
    public static void main(String[] args) throws InterruptedException {
        AtomicCounter counter = new AtomicCounter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task, "Thread-X");
        Thread t2 = new Thread(task, "Thread-Y");

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("最终计数: " + counter.getCount()); // 期望是 2000
    }
}
```

##### E. 线程安全集合类 (Concurrency Collections)

* `java.util.concurrent` 包中提供了许多线程安全的集合类，如 `ConcurrentHashMap`, `CopyOnWriteArrayList`, `CopyOnWriteArraySet`, `BlockingQueue` 等。
* 它们在内部通过更高效的并发算法（如分段锁、CAS、读写锁）来保证线程安全，通常比同步包装器（如 `Collections.synchronizedList()`) 性能更好。

#### 3. 线程间通信

除了同步对共享资源的访问，线程之间通常还需要进行协作和通信。

* **`wait()`, `notify()`, `notifyAll()` (基于 `Object` 和 `synchronized` 锁)：** 实现生产者-消费者模式等经典问题。
    * `wait()`：释放锁，并使当前线程进入等待状态。
    * `notify()`：唤醒一个正在等待该对象锁的线程。
    * `notifyAll()`：唤醒所有正在等待该对象锁的线程。
* **`Condition` (与 `Lock` 配合)：** 提供了更细粒度的等待/通知机制，可以有多个等待队列。
* **`BlockingQueue`：** 阻塞队列，在生产者-消费者模型中非常有用。当队列满时生产者阻塞，队列空时消费者阻塞。
* **`CountDownLatch`, `CyclicBarrier`, `Semaphore`：** `java.util.concurrent` 包中提供的更高级的同步工具，用于协调复杂的线程协作。

#### 4. 总结与选择

选择合适的线程同步机制取决于具体的需求和场景：

* **简单同步：** 对于简单的方法或代码块同步，且对性能要求不是极致，**`synchronized` 关键字**通常是首选，它使用方便且 JVM 有很多优化。
* **高级同步或需要更多控制：** 当需要尝试获取锁、可中断锁、公平性、多个条件变量等高级功能时，使用 **`Lock` 接口及其实现（如 `ReentrantLock`）**。
* **单一变量的原子操作：** 使用 **`java.util.concurrent.atomic` 包中的原子类**，性能通常最优。
* **可见性保证：** `volatile` 用于保证变量的可见性，但不保证原子性，适用于状态标志等。
* **高并发集合：** 在多线程环境下使用 **`java.util.concurrent` 包中的并发集合**。
* **线程协作：** 使用 `wait()/notify()` 或 `Condition` 进行线程间的通信，使用 `BlockingQueue` 实现生产者-消费者模式，使用其他并发工具进行更复杂的协调。

理解和正确应用这些线程同步机制是编写健壮、高效且无死锁的多线程 Java 应用程序的关键。
## 死锁
好的，我们来详细讲解 Java 中的**死锁 (Deadlock)** 现象。

---

### Java 中的死锁 (Deadlock) 详解

**死锁 (Deadlock)** 是多线程编程中一个非常严重且难以调试的问题。当两个或多个线程在互相等待对方释放资源时，它们会陷入一种无限期的等待状态，导致程序停滞不前，无法继续执行。

简单来说，就是“你等我，我等你，结果谁也走不了”。

#### 1. 死锁的发生场景

死锁通常发生在多个线程尝试获取多个共享资源（通常是锁）时。

**经典死锁场景：**
假设有两个线程 `Thread-A` 和 `Thread-B`，以及两个资源 `Resource-X` 和 `Resource-Y`。
1.  `Thread-A` 尝试获取 `Resource-X` 的锁。
2.  `Thread-A` 成功获取 `Resource-X` 的锁。
3.  `Thread-B` 尝试获取 `Resource-Y` 的锁。
4.  `Thread-B` 成功获取 `Resource-Y` 的锁。
5.  `Thread-A` 尝试获取 `Resource-Y` 的锁（但 `Resource-Y` 被 `Thread-B` 占用，所以 `Thread-A` 阻塞）。
6.  `Thread-B` 尝试获取 `Resource-X` 的锁（但 `Resource-X` 被 `Thread-A` 占用，所以 `Thread-B` 阻塞）。

结果：`Thread-A` 等待 `Thread-B` 释放 `Resource-Y`，而 `Thread-B` 等待 `Thread-A` 释放 `Resource-X`。它们陷入了相互等待，谁也无法继续执行，这就是死锁。

#### 2. 死锁发生的四个必要条件

死锁的发生必须同时满足以下四个条件（由 C.A.R. Hoare 在 1960 年代提出）：

1.  **互斥条件 (Mutual Exclusion)：**
    * 资源是非共享的，即在任何一个时刻，一个资源只能被一个线程独占使用。
    * 例子：一个打印机在同一时间只能被一个用户使用；一个 `synchronized` 锁在同一时间只能被一个线程持有。

2.  **请求与保持条件 (Hold and Wait / Resource Holding)：**
    * 一个线程已经持有了至少一个资源，但又提出了新的资源请求，而它请求的新资源却被其他线程占用。
    * 在等待新资源的同时，它不释放已经持有的资源。

3.  **不剥夺条件 (No Preemption)：**
    * 线程已经获得的资源在未使用完之前，不能被外部（其他线程或操作系统）强制剥夺，只能由持有该资源的线程自愿释放。

4.  **循环等待条件 (Circular Wait)：**
    * 存在一个线程资源的循环链，即线程 A 在等待线程 B 持有的资源，线程 B 在等待线程 C 持有的资源，...，线程 N 在等待线程 A 持有的资源。
    * 形成一个闭环，每个线程都在等待这个环中的下一个线程所持有的资源。

**死锁只有当这四个条件同时满足时才会发生。只要破坏其中任何一个条件，就可以避免死锁。**

#### 3. 死锁示例 (Java 代码)

```java
public class DeadlockDemo {

    // 定义两个锁对象
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) {
        // 线程 1：先尝试获取 lock1，再尝试获取 lock2
        Thread thread1 = new Thread(() -> {
            synchronized (lock1) { // 线程 1 获取 lock1
                System.out.println("线程 1: 获得了 lock1");
                try {
                    Thread.sleep(50); // 模拟一些工作，给线程 2 机会获取 lock2
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程 1: 尝试获取 lock2...");
                synchronized (lock2) { // 线程 1 尝试获取 lock2
                    System.out.println("线程 1: 获得了 lock2");
                }
            }
            System.out.println("线程 1: 完成。");
        }, "Thread-1");

        // 线程 2：先尝试获取 lock2，再尝试获取 lock1
        Thread thread2 = new Thread(() -> {
            synchronized (lock2) { // 线程 2 获取 lock2
                System.out.println("线程 2: 获得了 lock2");
                try {
                    Thread.sleep(50); // 模拟一些工作，给线程 1 机会获取 lock1
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程 2: 尝试获取 lock1...");
                synchronized (lock1) { // 线程 2 尝试获取 lock1
                    System.out.println("线程 2: 获得了 lock1");
                }
            }
            System.out.println("线程 2: 完成。");
        }, "Thread-2");

        // 启动两个线程
        thread1.start();
        thread2.start();

        System.out.println("主线程启动了两个可能导致死锁的线程。");
    }
}
```

**运行上述代码，你很可能会发现程序在输出到“线程 1: 尝试获取 lock2...”和“线程 2: 尝试获取 lock1...”之后就卡住了，不再有任何输出，这就是死锁的发生。**

#### 4. 如何避免死锁？ (破坏死锁的四个必要条件)

避免死锁就是破坏上述四个必要条件中的至少一个。

1.  **破坏互斥条件：** (通常不可行或无意义)
    * 将共享资源设计为可共享的（例如，使用无锁数据结构，如 `ConcurrentHashMap`，或者使用 `volatile` 保证可见性，但 `volatile` 不能替代锁解决原子性问题）。
    * 但很多资源天生就是互斥的（例如，一个文件句柄，一个打印机），所以这个条件通常无法被破坏。

2.  **破坏请求与保持条件：**
    * **一次性申请所有资源：** 线程在开始执行之前，一次性申请它所需的所有资源。如果不能全部获得，就一个都不持有，并释放已经持有的资源，然后重新尝试。
        * **优点：** 简单。
        * **缺点：** 降低资源利用率（资源可能长时间被占用），可能导致饥饿（线程总是无法一次性获取所有资源）。
    * **示例：**
        ```java
        // 线程 1
        synchronized (lock1) {
            // 如果获取不到 lock2，则释放 lock1，再重试
            // 这种逻辑用 Lock 接口的 tryLock() 更容易实现
            synchronized (lock2) {
                // ...
            }
        }
        ```

3.  **破坏不剥夺条件：** (通常不可行或复杂)
    * 允许系统（或线程）从持有资源的线程那里“抢夺”资源。
    * 这通常很复杂，因为强制剥夺资源可能导致数据不一致或其他问题（例如，从一个正在写入文件的线程那里剥夺文件锁）。
    * `java.util.concurrent.locks.Lock` 接口的 `tryLock()` 方法可以实现尝试获取锁，如果获取不到就放弃的功能，这间接实现了“非剥夺”的变种（如果获取不到就主动放弃，而不是持有并等待）。

4.  **破坏循环等待条件 (最常用和有效的方式)：**
    * **对所有资源进行排序，并强制线程按照相同的顺序获取资源。**
    * 例如，规定 `lock1` 的顺序总是优先于 `lock2`。所有线程在需要获取 `lock1` 和 `lock2` 时，都必须先获取 `lock1`，再获取 `lock2`。
    * 这样可以打破循环等待，因为线程 A 持有 `lock1` 并等待 `lock2`，线程 B 如果需要 `lock1` 和 `lock2`，它会先尝试获取 `lock1`，如果 `lock1` 被 A 持有，B 就会阻塞，不会去获取 `lock2`，从而避免了循环等待。

    **示例 (避免死锁的版本)：**
    ```java
    public class NoDeadlockDemo {

        private static final Object lock1 = new Object();
        private static final Object lock2 = new Object();

        public static void main(String[] args) {
            // 线程 1：先获取 lock1，再获取 lock2 (与之前相同)
            Thread thread1 = new Thread(() -> {
                synchronized (lock1) {
                    System.out.println("线程 1: 获得了 lock1");
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("线程 1: 尝试获取 lock2...");
                    synchronized (lock2) {
                        System.out.println("线程 1: 获得了 lock2");
                    }
                }
                System.out.println("线程 1: 完成。");
            }, "Thread-1");

            // 线程 2：也先获取 lock1，再获取 lock2 (修改了顺序)
            Thread thread2 = new Thread(() -> {
                synchronized (lock1) { // 线程 2 也先尝试获取 lock1
                    System.out.println("线程 2: 获得了 lock1");
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("线程 2: 尝试获取 lock2...");
                    synchronized (lock2) { // 线程 2 再尝试获取 lock2
                        System.out.println("线程 2: 获得了 lock2");
                    }
                }
                System.out.println("线程 2: 完成。");
            }, "Thread-2");

            thread1.start();
            thread2.start();

            System.out.println("主线程启动了两个不会死锁的线程。");
            // 你会发现这两个线程都能顺利完成，不会卡住
        }
    }
    ```
    在这个修改后的例子中，如果 `Thread-1` 先获得了 `lock1`，那么当 `Thread-2` 尝试获取 `lock1` 时，它会阻塞，直到 `Thread-1` 完成并释放 `lock1` 和 `lock2`。这样就打破了循环等待，避免了死锁。

#### 5. 发现死锁

* **人工审查：** 在复杂的并发代码中很难发现。
* **工具检测：**
    * **JConsole / VisualVM：** Java 自带的监控工具，可以连接到运行中的 JVM，查看线程的详细信息和状态，包括是否处于死锁状态。
    * **线程 Dump (Thread Dump)：** 通过 `jstack <pid>` 命令可以生成线程堆栈信息，其中会明确标记出死锁的线程。这是生产环境中诊断死锁的常用方法。

#### 总结

死锁是多线程编程中必须警惕的严重问题。它由互斥、请求与保持、不剥夺、循环等待四个必要条件共同导致。在实际开发中，最常用和最有效的避免死锁的方法是**破坏循环等待条件，即强制所有线程以一致的顺序获取多个锁**。此外，合理使用 `java.util.concurrent.locks.Lock` 接口提供的 `tryLock()` 等高级功能也可以帮助规避死锁风险。
## 线程间通信
好的，我们来详细讲解 Java 中的**线程间通信 (Inter-Thread Communication)**。

---

### Java 线程间通信 (Inter-Thread Communication) 详解

在多线程编程中，线程之间不仅需要同步访问共享资源，还常常需要**协同工作**，即一个线程的执行依赖于另一个线程的状态或结果。这种线程之间的协作过程就是**线程间通信 (Inter-Thread Communication)**。

线程间通信是解决多线程复杂业务逻辑的关键，它允许线程在满足特定条件时暂停执行，并在条件满足时被唤醒，从而实现任务的有序推进。

#### 1. 为什么需要线程间通信？

考虑一个经典的**生产者-消费者 (Producer-Consumer)** 模型：
* **生产者线程：** 负责生成数据，并将数据放入一个共享的缓冲区。
* **消费者线程：** 负责从共享缓冲区中取出数据并进行处理。

如果没有通信机制：
* 如果缓冲区满了，生产者还在继续生产，就会导致数据溢出或覆盖。
* 如果缓冲区空了，消费者还在继续消费，就会尝试读取不存在的数据，导致错误。

线程间通信机制能够让生产者在缓冲区满时“等待”消费者消费，让消费者在缓冲区空时“等待”生产者生产，从而实现协调和同步。

#### 2. 线程间通信的几种主要方式

Java 提供了多种线程间通信的机制，从基于 `Object` 类的方法到 `java.util.concurrent` 包中的高级工具。

##### A. `wait()`, `notify()`, `notifyAll()` (基于 `Object` 类)

这是 Java 最基础也是最重要的线程间通信机制。它们都是 `Object` 类的方法，而不是 `Thread` 类的方法，这意味着任何对象都可以作为锁和通信的媒介。

**核心概念：**
* **锁对象 (Monitor / Intrinsic Lock)：** `wait()`, `notify()`, `notifyAll()` 方法必须在**同步代码块或同步方法内部**调用，并且是针对**同一个锁对象**调用的。
* **等待队列 (Wait Set)：** 每个锁对象都有一个与之关联的等待队列。当线程调用 `wait()` 时，它会释放该锁并进入该对象的等待队列，直到被唤醒。

**方法详解：**

1.  **`public final void wait() throws InterruptedException`：**
    * **作用：** 使当前线程（调用 `wait()` 的线程）进入等待状态，并**释放它所持有的锁对象**。线程进入该对象的等待队列。
    * **何时调用：** 当线程发现某个条件不满足，无法继续执行时（例如，消费者发现缓冲区为空），它就调用 `wait()` 来暂停自己，等待条件满足。
    * **唤醒：** 线程会一直等待，直到被其他线程调用相同锁对象的 `notify()` 或 `notifyAll()` 方法唤醒，或者被中断。被唤醒后，它需要重新竞争该锁才能继续执行。

2.  **`public final void wait(long timeout) throws InterruptedException`：**
    * **作用：** 与 `wait()` 类似，但会等待指定的毫秒数。如果超时，线程会自动唤醒（但不保证立即获得锁）。

3.  **`public final void notify()`：**
    * **作用：** 唤醒在该对象锁的等待队列中**一个**任意等待的线程。
    * **何时调用：** 当线程改变了某个条件，使得其他等待的线程可能可以继续执行时（例如，生产者向缓冲区放入了数据）。
    * **不释放锁：** 调用 `notify()` 的线程不会立即释放锁，它会继续执行完同步代码块，然后才释放锁。

4.  **`public final void notifyAll()`：**
    * **作用：** 唤醒在该对象锁的等待队列中**所有**等待的线程。
    * **何时调用：** 当不确定哪个线程需要被唤醒，或者多个线程可能都需要被唤醒时。
    * **不释放锁：** 同样不立即释放锁。

**生产者-消费者模型示例：**

```java
import java.util.LinkedList;
import java.util.Queue;

class Storage {
    private final int MAX_SIZE = 5; // 缓冲区最大容量
    private final Queue<Integer> queue = new LinkedList<>(); // 共享缓冲区

    // 生产方法
    public void produce(int item) throws InterruptedException {
        synchronized (queue) { // 锁定队列对象
            while (queue.size() == MAX_SIZE) { // 如果缓冲区已满，则等待
                System.out.println(Thread.currentThread().getName() + ": 缓冲区已满，等待消费者消费...");
                queue.wait(); // 释放锁，进入等待状态
            }
            queue.offer(item); // 生产数据
            System.out.println(Thread.currentThread().getName() + ": 生产了 " + item + "，当前容量: " + queue.size());
            queue.notifyAll(); // 唤醒所有等待的消费者
        }
    }

    // 消费方法
    public int consume() throws InterruptedException {
        synchronized (queue) { // 锁定队列对象
            while (queue.isEmpty()) { // 如果缓冲区为空，则等待
                System.out.println(Thread.currentThread().getName() + ": 缓冲区为空，等待生产者生产...");
                queue.wait(); // 释放锁，进入等待状态
            }
            int item = queue.poll(); // 消费数据
            System.out.println(Thread.currentThread().getName() + ": 消费了 " + item + "，当前容量: " + queue.size());
            queue.notifyAll(); // 唤醒所有等待的生产者
            return item;
        }
    }
}

class Producer implements Runnable {
    private Storage storage;
    private int startValue;

    public Producer(Storage storage, int startValue) {
        this.storage = storage;
        this.startValue = startValue;
    }

    @Override
    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                storage.produce(startValue + i);
                Thread.sleep(50); // 模拟生产时间
            }
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + " 被中断.");
        }
    }
}

class Consumer implements Runnable {
    private Storage storage;

    public Consumer(Storage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                storage.consume();
                Thread.sleep(150); // 模拟消费时间
            }
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + " 被中断.");
        }
    }
}

public class WaitNotifyDemo {
    public static void main(String[] args) throws InterruptedException {
        Storage storage = new Storage();

        Thread producer1 = new Thread(new Producer(storage, 1), "Producer-1");
        Thread producer2 = new Thread(new Producer(storage, 101), "Producer-2");
        Thread consumer1 = new Thread(new Consumer(storage), "Consumer-1");
        Thread consumer2 = new Thread(new Consumer(storage), "Consumer-2");

        producer1.start();
        producer2.start();
        consumer1.start();
        consumer2.start();

        // 简短等待所有线程完成，以便观察输出
        Thread.sleep(3000); // 主线程等待 3 秒
        System.out.println("\n主线程：演示结束，可能还有线程在运行或等待。");

        // 强行中断所有线程，以便程序结束
        producer1.interrupt();
        producer2.interrupt();
        consumer1.interrupt();
        consumer2.interrupt();
    }
}
```

##### B. `java.util.concurrent.locks.Condition` (与 `Lock` 配合)

`Condition` 接口与 `Lock` 接口（如 `ReentrantLock`）配合使用，提供了比 `wait()`, `notify()`, `notifyAll()` 更灵活、更强大的线程间通信机制。

**特点：**
* **多条件队列：** 一个 `Lock` 对象可以创建多个 `Condition` 对象。每个 `Condition` 对象都相当于一个独立的等待队列。这使得线程可以更精确地选择在哪里等待和唤醒。
* **方法名：** `await()` 替代 `wait()`，`signal()` 替代 `notify()`，`signalAll()` 替代 `notifyAll()`。
* **与 `Lock` 绑定：** `Condition` 对象是通过 `Lock` 对象的 `newCondition()` 方法创建的，并且 `await()` 和 `signal()` 方法必须在获取 `Lock` 之后调用。

**示例 (生产者-消费者模型，使用 `Condition`)：**

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class StorageWithCondition {
    private final int MAX_SIZE = 5;
    private final Queue<Integer> queue = new LinkedList<>();
    private final Lock lock = new ReentrantLock(); // 使用 ReentrantLock
    // 创建两个 Condition：一个用于生产者等待空间，一个用于消费者等待数据
    private final Condition notFull = lock.newCondition();  // 缓冲区不满的条件
    private final Condition notEmpty = lock.newCondition(); // 缓冲区不空的条件

    public void produce(int item) throws InterruptedException {
        lock.lock(); // 获取锁
        try {
            while (queue.size() == MAX_SIZE) {
                System.out.println(Thread.currentThread().getName() + ": 缓冲区已满，等待 notFull...");
                notFull.await(); // 生产者等待，释放锁
            }
            queue.offer(item);
            System.out.println(Thread.currentThread().getName() + ": 生产了 " + item + "，当前容量: " + queue.size());
            notEmpty.signalAll(); // 唤醒所有等待 notEmpty 的消费者
        } finally {
            lock.unlock(); // 确保释放锁
        }
    }

    public int consume() throws InterruptedException {
        lock.lock(); // 获取锁
        try {
            while (queue.isEmpty()) {
                System.out.println(Thread.currentThread().getName() + ": 缓冲区为空，等待 notEmpty...");
                notEmpty.await(); // 消费者等待，释放锁
            }
            int item = queue.poll();
            System.out.println(Thread.currentThread().getName() + ": 消费了 " + item + "，当前容量: " + queue.size());
            notFull.signalAll(); // 唤醒所有等待 notFull 的生产者
            return item;
        } finally {
            lock.unlock(); // 确保释放锁
        }
    }
}

// Producer 和 Consumer 类与 WaitNotifyDemo 中的类似，只是构造器传入 StorageWithCondition
// main 方法也类似，只是创建 StorageWithCondition 实例

public class ConditionDemo {
    public static void main(String[] args) throws InterruptedException {
        StorageWithCondition storage = new StorageWithCondition();

        Thread producer1 = new Thread(new Producer(storage, 1), "Producer-A");
        Thread producer2 = new Thread(new Producer(storage, 101), "Producer-B");
        Thread consumer1 = new Thread(new Consumer(storage), "Consumer-X");
        Thread consumer2 = new Thread(new Consumer(storage), "Consumer-Y");

        producer1.start();
        producer2.start();
        consumer1.start();
        consumer2.start();

        Thread.sleep(3000);
        System.out.println("\n主线程：演示结束，可能还有线程在运行或等待。");

        producer1.interrupt();
        producer2.interrupt();
        consumer1.interrupt();
        consumer2.interrupt();
    }
}
```

##### C. `java.util.concurrent.BlockingQueue` (阻塞队列)

这是 Java 并发包中最常用、最推荐的线程间通信机制之一，特别适用于生产者-消费者模式。

**特点：**
* **自带同步和通信机制：** `BlockingQueue` 是一个线程安全的队列。它内部封装了同步和通信逻辑，你无需手动使用 `synchronized`, `wait()`, `notify()` 或 `Lock`, `Condition`。
* **阻塞操作：**
    * 当队列满时，生产者调用 `put()` 方法会被阻塞，直到队列有空间。
    * 当队列空时，消费者调用 `take()` 方法会被阻塞，直到队列有数据。
* **多种实现：** `ArrayBlockingQueue` (有界，基于数组), `LinkedBlockingQueue` (可选有界，基于链表), `PriorityBlockingQueue` (无界，基于优先级), `DelayQueue` 等。

**示例 (生产者-消费者模型，使用 `BlockingQueue`)：**

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

// Producer 和 Consumer 类可以复用，只需修改构造器接收 BlockingQueue

class ProducerWithBlockingQueue implements Runnable {
    private BlockingQueue<Integer> queue;
    private int startValue;

    public ProducerWithBlockingQueue(BlockingQueue<Integer> queue, int startValue) {
        this.queue = queue;
        this.startValue = startValue;
    }

    @Override
    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                int item = startValue + i;
                queue.put(item); // 队列满时会自动阻塞
                System.out.println(Thread.currentThread().getName() + ": 生产了 " + item + "，当前容量: " + queue.size());
                Thread.sleep(50);
            }
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + " 被中断.");
        }
    }
}

class ConsumerWithBlockingQueue implements Runnable {
    private BlockingQueue<Integer> queue;

    public ConsumerWithBlockingQueue(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            for (int i = 0; i < 10; i++) {
                int item = queue.take(); // 队列空时会自动阻塞
                System.out.println(Thread.currentThread().getName() + ": 消费了 " + item + "，当前容量: " + queue.size());
                Thread.sleep(150);
            }
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + " 被中断.");
        }
    }
}

public class BlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        // 创建一个容量为 3 的有界阻塞队列
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(3);

        Thread producer1 = new Thread(new ProducerWithBlockingQueue(queue, 1), "Producer-P");
        Thread producer2 = new Thread(new ProducerWithBlockingQueue(queue, 101), "Producer-Q");
        Thread consumer1 = new Thread(new ConsumerWithBlockingQueue(queue), "Consumer-M");
        Thread consumer2 = new Thread(new ConsumerWithBlockingQueue(queue), "Consumer-N");

        producer1.start();
        producer2.start();
        consumer1.start();
        consumer2.start();

        Thread.sleep(3000);
        System.out.println("\n主线程：演示结束，可能还有线程在运行或等待。");

        producer1.interrupt();
        producer2.interrupt();
        consumer1.interrupt();
        consumer2.interrupt();
    }
}
```

##### D. 其他并发工具

`java.util.concurrent` 包中还有其他用于线程协作和通信的工具：

* **`CountDownLatch` (倒计时门闩)：** 一个或多个线程等待其他线程完成一系列操作。
* **`CyclicBarrier` (循环屏障)：** 允许多个线程相互等待，直到所有线程都到达一个公共屏障点，然后它们可以同时继续执行。
* **`Semaphore` (信号量)：** 控制同时访问某个资源的线程数量。
* **`Exchanger` (交换器)：** 允许两个线程在某个同步点交换数据。

#### 3. 总结与最佳实践

线程间通信是多线程编程中实现复杂逻辑的关键。

* **最基础：** `wait()`, `notify()`, `notifyAll()`。它们与 `synchronized` 关键字紧密结合，理解它们的语义需要深入理解 Java 对象的锁和等待队列。
* **更灵活：** `Condition` 接口。与 `Lock` 配合使用，提供多条件等待队列，避免“虚假唤醒”和提供更细粒度的控制。
* **最推荐（特定模式）：** `BlockingQueue`。在生产者-消费者模式中，它极大地简化了代码，是首选方案，因为它内部已经处理了所有的同步和通信细节。
* **高级协作：** `CountDownLatch`, `CyclicBarrier`, `Semaphore` 等工具用于解决更复杂的线程协作场景。

在选择线程间通信方式时，应优先考虑使用 `java.util.concurrent` 包中提供的更高级、更抽象、更安全的工具，它们通常比手动管理 `wait()/notify()` 更不容易出错且性能更好。