## 继承
### 面向对象程序设计语言的继承
# Inheritance in Object-Oriented Programming Languages

## 继承的种类
## Types of Inheritance

在面向对象编程中，继承是允许一个类（子类）获取另一个类（父类）的属性和方法的机制。根据语言特性，继承主要分为两种：

In object-oriented programming, inheritance is a mechanism that allows one class (subclass) to acquire the properties and methods of another class (parent class). Based on language features, inheritance is mainly divided into two types:

* **单继承 (Single Inheritance):**
    * 定义：只继承一个父类。
    * 示例语言：Java。
    * Definition: Only inherits from a single parent class.
    * Example Language: Java.

* **多继承 (Multiple Inheritance):**
    * 定义：可以继承多个父类。
    * 示例语言：C++。
    * Definition: Can inherit from multiple parent classes.
    * Example Language: C++.

### 定义子类 (Java 示例)
### Defining Subclasses (Java Example)

在Java中，使用 `extends` 关键字来定义子类，实现类的单继承。

In Java, the `extends` keyword is used to define a subclass, implementing single inheritance for classes.

### 1) 格式 (Format):

```java
[修饰符] class 子类 extends 父类 {
    //ClassBody 类体
}
public class Person{
    //classbody
}

public class Teacher extends Person{
    //classbody
}

public class Student extends Person{
    //classbody
}
```
### 子类继承了父类中哪些成员？
         除了static成员，构造方法外，子类会继承父类中其它所有的成员，包括private的成员。

### Java 继承中的访问权限
### Access Modifiers in Java Inheritance

**访问属性决定了子类可以访问从父类继承的哪些成员。**
**Access modifiers determine which members a subclass can access from its inherited parent class.**

| 父类的访问属性 (Parent's Access Modifier) | 同一个包 (Same Package) | 不同包 (Different Package) |
| :------------------------------ | :---------------------: | :-----------------------: |
| `private`                       |           N           |             N             |
| `默认` (Default/Package-private) |           Y           |             N             |
| `protected`                     |           Y           |             Y             |
| `public`                        |           Y           |             Y             |

(Y 表示可访问，N 表示不可访问)
(Y means accessible, N means not accessible)

---

**解释 (Explanation):**

这张表格清晰地展示了在 Java 中，当一个子类继承一个父类时，父类成员（如字段或方法）的访问修饰符如何影响子类对其的可见性和可访问性，尤其是在不同包的情况下。

This table clearly demonstrates how access modifiers of parent class members (such as fields or methods) affect their visibility and accessibility to subclasses in Java, especially when located in different packages.

* **`private`**:
    * 在任何情况下，`private` 成员都不能被子类直接访问，无论是同包还是不同包。`private` 成员只能在其定义的类内部被访问。
    * `private` members cannot be directly accessed by subclasses under any circumstances, whether in the same package or a different package. `private` members are only accessible within the class where they are defined.

* **`默认` (Default / Package-private)**:
    * 如果父类成员没有显式地使用 `public`, `protected`, 或 `private` 修饰，它就是默认（包私有）访问级别。
    * 在同一个包内，子类可以访问父类的默认成员。
    * 在不同的包中，子类不能访问父类的默认成员。
    * If a parent class member does not explicitly use `public`, `protected`, or `private` modifiers, it has default (package-private) access.
    * Within the same package, subclasses can access default members of the parent class.
    * In different packages, subclasses cannot access default members of the parent class.

* **`protected`**:
    * `protected` 成员可以在同一个包内被任何类访问。
    * 更重要的是，它们可以被不同包中的子类访问（通过继承关系）。
    * `protected` members can be accessed by any class within the same package.
    * Crucially, they can also be accessed by subclasses in different packages (through inheritance).

* **`public`**:
    * `public` 成员具有最广泛的访问权限。
    * 它们可以被任何地方的任何类访问，包括同一个包或不同包中的子类。
    * `public` members have the broadest access.
    * They can be accessed by any class from anywhere, including subclasses in the same or different packages.

**总结 (Summary):**
这张表是理解 Java 封装和继承之间关系的关键。它指导开发者如何使用适当的访问修饰符来控制类的成员在继承层次结构中的可见性，从而维护程序的健壮性和安全性。

This table is crucial for understanding the relationship between encapsulation and inheritance in Java. It guides developers on how to use appropriate access modifiers to control the visibility of class members within an inheritance hierarchy, thereby maintaining program robustness and security.     

### 类成员的隐藏与重载
**继承了父类同名的成员变量和成员函数**
#### 成员变量的隐藏
　　　当子类定义与父类具有相同名字的成员变量时，子类会将父类相应的成员变量隐藏起来。
#### 成员方法的隐藏：重构(overriding)           重点    
　　　当子类定义与父类具有相同签名的成员方法时，子类会将父类相应的成员方法隐藏起来。
        
#### 成员方法的重载(overloading)：　扩展父类的方法。 
　　　当子类定义了与父类具有同名，但参数不同（数目或类型）的成员方法时，构成了成员方法的重载。
    
### super关键字：父类的引用。
#### 1）调用被隐藏的父类成员变量或重构的父类成员方法。
##### Java Inheritance Example: Member Hiding and Method Overriding

This example demonstrates key concepts of inheritance in Java, specifically **member variable hiding** and **method overriding**.

#### Code Analysis

Let's break down the provided Java code:

```java
class Parent {
    String name = " Parent "; // Parent's name variable
    int age = 1;              // Parent's age variable

    public void pr() {
        System.out.println("pr Parent "); // Parent's pr() method
    }
}

public class Child extends Parent {
    String name = " Child "; // Child's own name variable (hides Parent's name)
    int age = 2;              // Child's own age variable (hides Parent's age)

    public void pr() {
        System.out.println("pr Child "); // Child's pr() method (overrides Parent's pr())
    }

    public void prNameAge() {
        // Accessing Child's own hidden members
        System.out.println(name + age);

        // Accessing Parent's hidden members using 'super'
        System.out.println(super.name + super.age);

        // Calling Child's overridden pr() method
        pr();

        // Calling Parent's original pr() method using 'super'
        super.pr();
    }

    public static void main(String[] args) {
        Child myChild = new Child(); // Create an instance of Child
        myChild.prNameAge();         // Call the prNameAge() method
    }
}
```
### 2）子类的构造方法中调用父类的构造方法。    
　　在子类的构造方法中，利用super(参数)调用父类的构造方法，并且作为第一条语句。	
**notice:** 如果在子类的构造方法中，没有显示地利用super(参数)调用父类的构造方法，那么就会在子类的构造方法中第一条语句处，自动插入一条super()语句来调用父类的构造方法。
```java
class Parent {
       Parent(String str) {
           System.out.println("Parent");
       }
   }
public class Child extends Parent {
    Child(String str) {
        super(str); // Calls the Parent class constructor
        System.out.println("child");
    }

    public static void main(String[] args) {
        new Child("Tom"); // Object creation
    }
}
```

### 理解 Java 中的 `Object` 类与 `toString()` 方法

此幻灯片强调了 Java 中的一个基本概念：所有类都直接或间接地继承自 `Object` 类，因此也继承了 `Object` 类的方法，包括 `toString()` 方法。

#### 关键点：

1.  **通用超类：** Java 中的任何类都是 `Object` 类的子类（直接或间接）。这意味着 `Object` 是 Java 类层次结构的根。

    * *示例：* 如果 `ClassA` 继承 `ClassB`，而 `ClassB` 继承 `Object`，那么 `ClassA` 就间接继承了 `Object`。如果一个类没有显式地继承其他类，它就隐式地继承了 `Object`。

2.  **`Object` 类的 `toString()` 方法：** `Object` 类提供了一个 `toString()` 方法。

    * **目的：** 这个方法旨在返回对象的字符串描述。
    * **默认实现：** 默认情况下，`Object` 类的 `toString()` 方法返回一个字符串，该字符串由类名、一个 '@' 符号以及对象的哈希码的无符号十六进制表示组成。
        * *格式：* `类名@十六进制哈希码`

#### 示例：

**例1: 显式调用 `toString()`**

```java
Teacher tom = new Teacher(); // 假设 Teacher 是一个自定义类
String str = tom.toString(); // 显式调用 'tom' 对象的 toString() 方法
// 'str' 将保存默认的字符串表示，例如："Teacher@14318bb"
```

**例2: 隐式调用 `toString()`**

当一个对象直接传递给 `System.out.println()` 时，该对象的 `toString()` 方法会自动被调用。

```java
System.out.println(tom); // 这等价于：
System.out.println(tom.toString());
// 两行代码将产生相同的输出，例如："Teacher@14318bb"
```

#### 意义：

* **默认字符串表示：** 默认的 `toString()` 方法提供了一个对象在内存中的基本、唯一的标识符。
* **重写 `toString()`：** 开发者通常会在自定义类中**重写**（Override） `toString()` 方法，以提供一个更具意义且易于人类阅读的对象状态（其属性/数据）的字符串表示。这对于调试和日志记录至关重要。


### JVM 对象创建过程（涉及继承）

此图详细描述了 Java 虚拟机（JVM）在创建新对象时所执行的步骤，特别是在涉及继承的情况下。示例中展示了 `Teacher` 对象的创建，这意味着 `Teacher` 是一个类，并且它很可能继承自一个超类（例如 `Object` 或其他自定义类）。

**正在执行的语句：**
`Teacher tom = new Teacher(1, "Tom", "男", "计算机系", "教授", 6000);`

**核心原则：** "只加载和初始化一次"。这指的是一个类的静态成员和静态代码块只在该类首次被主动使用时才处理。

**当运行此语句时，JVM 做了什么：**

该过程可以分为两个主要阶段：**类加载与初始化** 和 **对象实例化**。

#### 阶段1: 类加载与初始化（针对类）

此阶段在 JVM 生命周期中每个类只发生*一次*。

1.  **(1) 加载父类：** JVM 将 `Teacher` 类的直接或间接父类（如果存在）的字节码加载到内存中。这涉及查找 `.class` 文件。
2.  **(2) 初始化父类：** 父类被初始化。这包括：
    * 执行**静态初始化块**（`static {}` 块）。
    * 给**静态变量**（类变量）赋初始值。
3.  **(3) 加载子类：** JVM 将 `Teacher`（子）类的字节码加载到内存中。
4.  **(4) 初始化子类：** `Teacher`（子）类被初始化。这包括：
    * 执行**静态初始化块**（`static {}` 块）。
    * 给**静态变量**（类变量）赋初始值。

#### 阶段2: 对象实例化（针对特定对象）

此阶段在每次使用 `new` 关键字时都会发生。

5.  **(5) 在堆中分配空间给子对象：** JVM 在堆内存中为新的 `Teacher` 对象分配内存空间。此空间包括所有实例变量（无论是继承的还是在 `Teacher` 中声明的）所需的内存。
6.  **(6) 执行父类中的实例块或给父类中的实例变量赋值：**
    * 执行父类中存在的任何**实例初始化块**（`{}` 块）。
    * 给父类中声明的**实例变量**（非静态字段）赋初始值。（这些通常在对象创建时或在构造器运行之前完成。）
7.  **(7) 执行父类的构造方法：** 执行父类的构造器。这通常是由子类构造器中的隐式或显式 `super()` 调用启动的。
8.  **(8) 执行子类中的实例块或给子类中的实例变量赋值：**
    * 执行子类（`Teacher`）中存在的任何**实例初始化块**（`{}` 块）。
    * 给子类（`Teacher`）中声明的**实例变量**（非静态字段）赋初始值。
9.  **(9) 执行子类的构造方法，完成子对象的创建。并由一个引用指向该对象。** 执行子类（`Teacher`）的构造器，完成对象的创建。最后，一个指向这个新创建对象的引用被返回，并由 `tom` 变量指向。
  
This is an excellent step-by-step breakdown of the JVM's execution process for a Java program, specifically focusing on class loading, initialization, and object creation within the context of inheritance. The provided code snippet `TestInherit.java` creates a `Teacher` object and calls its `speak()` method.

Let's organize and optimize this explanation in both English and Chinese, providing the complete markdown source code.

---

#### JVM Execution Flow: Class Loading, Initialization, and Object Instantiation

This document details the precise sequence of operations performed by the Java Virtual Machine (JVM) when executing a simple Java program involving custom classes and inheritance.

**Code Snippet:**

```java
public class TestInherit {
    public static void main(String[] args) {
        Teacher tom = new Teacher(1, "tom", "男", "计算机系", "教授", 6000);
        tom.speak();
    }
}
```

#### JVM 执行流程：类加载、初始化与对象实例化

本文档详细说明了 Java 虚拟机（JVM）在执行一个包含自定义类和继承的简单 Java 程序时所执行的精确操作序列。

**代码片段：**

```java
public class TestInherit {
    public static void main(String[] args) {
        Teacher tom = new Teacher(1, "tom", "男", "计算机系", "教授", 6000);
        tom.speak();
    }
}
```

**根据执行过程的假设：**

* `Teacher` 是一个类。
* `Teacher` 继承自一个超类，在执行步骤中被标识为 `Person`。
* `Teacher` 类有一个接受指定参数的构造器。
* `Teacher` 类有一个 `speak()` 方法。

#### 详细的 JVM 执行过程：

执行过程大致可分为加载和初始化 `TestInherit` 类，然后执行其 `main` 方法中的操作。

1.  **加载 `TestInherit` 类：** JVM 将 `TestInherit.class` 字节码加载到方法区（Java 8+ 中为 Metaspace）。在此过程中，会建立 `TestInherit` 类的方法表，将方法名映射到其实际实现。
2.  **初始化 `TestInherit` 类：** `TestInherit` 类被初始化。这包括：
    * 执行任何静态初始化块（`static {}`）。
    * 为 `TestInherit` 中声明的任何静态（类）变量赋初始值。
3.  **执行 `TestInherit.main` 方法：** JVM 开始执行 `TestInherit` 类的 `main` 方法。
    * **(3.1) 加载父类 (`Person`)：** 当遇到 `new Teacher(...)` 语句时，JVM 识别到 `Teacher` 继承自 `Person`。因此，`Person.class` 字节码被加载到方法区，并建立其方法表。
    * **(3.2) 初始化父类 (`Person`)：** `Person` 类被初始化。这包括：
        * 执行 `Person` 中的任何静态初始化块。
        * 为 `Person` 中声明的任何静态（类）变量赋初始值。
    * **(3.3) 加载子类 (`Teacher`)：** `Teacher.class` 字节码被加载到方法区，并建立其方法表。
    * **(3.4) 初始化子类 (`Teacher`)：** `Teacher` 类被初始化。这包括：
        * 执行 `Teacher` 中的任何静态初始化块。
        * 为 `Teacher` 中声明的任何静态（类）变量赋初始值。
    * **(3.5) 在堆中分配空间给 `Teacher` 对象：** JVM 在堆内存中为新的 `Teacher` 对象分配内存空间。此空间包括所有实例变量（从 `Person` 继承的和在 `Teacher` 中声明的）所需的内存。
    * **(3.6) 执行父类 (`Person`) 中的实例块或给 `Person` 中的实例变量赋值：** 执行 `Person` 类中存在的任何实例初始化块（`{}` 块），并为在 `Person` 中声明的非静态（实例）变量赋初始值。
    * **(3.7) 执行父类 (`Person`) 的构造方法：** 执行 `Person` 类的构造器。这通常是通过 `Teacher` 构造器中隐式或显式的 `super(...)` 调用启动的。
    * **(3.8) 执行子类 (`Teacher`) 中的实例块或给 `Teacher` 中的实例变量赋值：** 执行 `Teacher` 类中存在的任何实例初始化块（`{}` 块），并为在 `Teacher` 中声明的非静态（实例）变量赋初始值。
    * **(3.9) 执行子类 (`Teacher`) 的构造方法，完成子对象的创建。并由 `tom` 引用指向该子类对象。** 执行 `Teacher` 类的构造器，完成对象的创建。然后，一个指向这个新创建的 `Teacher` 对象的引用被赋值给 `tom` 变量。
    * **(3.10) 执行子类中的 `speak()` 方法：** 执行 `tom.speak()` 方法调用。JVM 使用对象的实际类型 (`Teacher`) 及其方法表来查找并调用正确的 `speak()` 方法实现。


#### JVM 执行流程：多对象实例化与继承

本文档详细说明了 Java 虚拟机（JVM）在执行一个涉及继承层次结构中创建多个不同自定义类对象的 Java 程序时所执行的精确操作序列。

**代码片段：**

```java
public class TestInherit3 {
    public static void main(String[] args) {
        // 创建一个 Teacher 对象并调用其 speak() 方法
        Teacher tom = new Teacher(1, "tom", "男", "计算机系", "教授", 6000);
        tom.speak();

        // 创建一个 Student 对象并调用其 speak() 方法
        Student rose = new Student(11, "rose", "女", "计算机", 600);
        rose.speak();
    }
}
```

**根据详细执行过程的假设：**

* `Teacher` 和 `Student` 是自定义类。
* `Teacher` 和 `Student` 都继承自一个共同的超类 `Person`。
* 所有必要的构造器和 `speak()` 方法都在相应的类中定义。

#### 详细的 JVM 执行过程：

执行过程大致可分为加载和初始化 `TestInherit3` 类，然后执行其 `main` 方法中的操作，其中涉及两个独立的对象创建序列。

1.  **加载 `TestInherit3` 类：** JVM 将 `TestInherit3.class` 字节码加载到方法区（或 Metaspace）。在此过程中，会建立 `TestInherit3` 类的方法表。
2.  **初始化 `TestInherit3` 类：** `TestInherit3` 类被初始化。这包括：
    * 执行任何静态初始化块（`static {}`）。
    * 为 `TestInherit3` 中声明的任何静态（类）变量赋初始值。
3.  **执行 `TestInherit3.main` 方法：** JVM 开始执行 `TestInherit3` 类的 `main` 方法。

    * **阶段 1: 创建 `Teacher` 对象 (`tom`)**
        * **(3.1) 加载父类 (`Person`)：** 当遇到 `new Teacher(...)` 语句时，JVM 识别到 `Teacher` 继承自 `Person`。如果 `Person.class` 尚未加载，其字节码将被加载到方法区，并建立其方法表。
        * **(3.2) 初始化父类 (`Person`)：** 如果 `Person` 尚未初始化，它将被初始化。这包括：
            * 执行 `Person` 中的任何静态初始化块。
            * 为 `Person` 中声明的任何静态（类）变量赋初始值。
        * **(3.3) 加载子类 (`Teacher`)：** 如果 `Teacher.class` 尚未加载，其字节码将被加载到方法区，并建立其方法表。
        * **(3.4) 初始化子类 (`Teacher`)：** 如果 `Teacher` 尚未初始化，它将被初始化。这包括：
            * 执行 `Teacher` 中的任何静态初始化块。
            * 为 `Teacher` 中声明的任何静态（类）变量赋初始值。
        * **(3.5) 在堆中分配空间给 `Teacher` 对象：** JVM 在堆内存中为新的 `Teacher` 对象分配内存空间。此空间包括所有实例变量（从 `Person` 继承的和在 `Teacher` 中声明的）所需的内存。
        * **(3.6) 执行父类 (`Person`) 中的实例块或给 `Person` 中的实例变量赋值：** 执行 `Person` 类中存在的任何实例初始化块（`{}` 块），并为在 `Person` 中声明的非静态（实例）变量赋初始值。
        * **(3.7) 执行父类 (`Person`) 的构造方法：** 执行 `Person` 类的构造器。这通常是通过 `Teacher` 构造器中隐式或显式的 `super(...)` 调用启动的。
        * **(3.8) 执行子类 (`Teacher`) 中的实例块或给 `Teacher` 中的实例变量赋值：** 执行 `Teacher` 类中存在的任何实例初始化块（`{}` 块），并为在 `Teacher` 中声明的非静态（实例）变量赋初始值。
        * **(3.9) 执行子类 (`Teacher`) 的构造方法，完成子对象的创建。并由 `tom` 引用指向该子类对象。** 执行 `Teacher` 类的构造器，完成对象的创建。然后，一个指向这个新创建的 `Teacher` 对象的引用被赋值给 `tom` 变量。
        * **(3.10) 执行 `tom` 子类对象的 `speak()` 方法：** 执行 `tom.speak()` 方法调用。JVM 使用对象的实际类型 (`Teacher`) 及其方法表来查找并调用正确的 `speak()` 方法实现。

    * **阶段 2: 创建 `Student` 对象 (`rose`)**
        * **(3.3) 加载子类 (`Student`)：** 当遇到 `new Student(...)` 语句时，如果 `Student.class` 尚未加载，其字节码将被加载到方法区，并建立其方法表。（注意：`Person` 类作为父类，如果 `Teacher` 已先处理，则 `Person` 已在步骤 3.1/3.2 中加载和初始化。如果 `Student` 是第一个被创建的对象，则 `Person` 将在此处加载和初始化。）
        * **(3.4) 初始化子类 (`Student`)：** 如果 `Student` 尚未初始化，它将被初始化。这包括：
            * 执行 `Student` 中的任何静态初始化块。
            * 为 `Student` 中声明的任何静态（类）变量赋初始值。
        * **(3.11) 在堆中分配空间给 `Student` 对象：** JVM 在堆内存中为新的 `Student` 对象分配内存空间。此空间包括所有实例变量（从 `Person` 继承的和在 `Student` 中声明的）所需的内存。
        * **(3.12) 执行父类 (`Person`) 中的实例块或给 `Person` 中的实例变量赋值：** 执行 `Person` 类中存在的任何实例初始化块（`{}` 块），并为在 `Person` 中声明的非静态（实例）变量赋初始值。（此步骤可能看起来冗余，如果 `Person` 的实例块/变量已经为 `Teacher` 处理过，但它指的是**新 Student 对象**的**实例**部分。）
        * **(3.13) 执行父类 (`Person`) 的构造方法：** 执行 `Person` 类的构造器。这通常是通过 `Student` 构造器中隐式或显式的 `super(...)` 调用启动的。
        * **(3.14) 执行子类 (`Student`) 中的实例块或给 `Student` 中的实例变量赋值：** 执行 `Student` 类中存在的任何实例初始化块（`{}` 块），并为在 `Student` 中声明的非静态（实例）变量赋初始值。
        * **(3.15) 执行子类 (`Student`) 的构造方法，完成子对象的创建。并由 `rose` 引用指向该子类对象。** 执行 `Student` 类的构造器，完成对象的创建。然后，一个指向这个新创建的 `Student` 对象的引用被赋值给 `rose` 变量。
        * **(3.16) 执行 `rose` 子类对象的 `speak()` 方法：** 执行 `rose.speak()` 方法调用。JVM 使用对象的实际类型 (`Student`) 及其方法表来查找并调用正确的 `speak()` 方法实现。



## 多态
## 抽象类
## 接口
## 包
### Java 中的“包”概念
### he Concept of "Packages" in Java

在 Java 中，“包”（Package）是一种用于组织类和接口的机制，类似于操作系统中的文件夹或目录。它在代码管理和访问控制方面扮演着关键角色。

In Java, a "package" is a mechanism used to organize classes and interfaces, similar to folders or directories in an operating system. It plays a crucial role in code management and access control.

### 包的主要作用
### Primary Functions of Packages

1.  **命名空间管理 (Namespace Management):**
    * **避免类名冲突：** 在大型项目或使用第三方库时，不同的开发者或库可能定义了同名的类。包通过为这些类提供一个独特的前缀（全限定名，`package.ClassName`），从而避免了命名冲突。
    * **Avoid Class Name Conflicts:** In large projects or when using third-party libraries, different developers or libraries might define classes with the same name. Packages provide a unique prefix (fully qualified name, `package.ClassName`) for these classes, thereby preventing naming conflicts.
    * *例如 (Example):* `com.example.myapp.User` 和 `org.anotherlib.data.User` 是两个不同的类。
    * *For instance:* `com.example.myapp.User` and `org.anotherlib.data.User` are two distinct classes.

2.  **访问控制 (Access Control):**
    * 包提供了一种特定的访问级别——默认（包私有）访问。这意味着没有显式使用 `public`, `protected`, 或 `private` 修饰符的类成员，只能在同一个包内的类中访问。
    * Packages offer a specific access level—default (package-private) access. This means that class members without explicit `public`, `protected`, or `private` modifiers are only accessible by classes within the same package.
    * 这正是之前表格中“默认”访问权限的含义。
    * This is precisely the meaning of "default" access in the previous table.

3.  **代码组织与可维护性 (Code Organization and Maintainability):**
    * 通过将功能相似或相关的类和接口组织到一起，包有助于提高项目的结构清晰度，使其更易于查找、理解和维护。
    * By grouping functionally similar or related classes and interfaces, packages help to improve the clarity of a project's structure, making it easier to locate, understand, and maintain.
    * *例如 (Example):* Java标准库将所有与输入/输出相关的类放在 `java.io` 包中，与数据结构相关的类放在 `java.util` 包中。
    * *For instance:* The Java standard library places all input/output related classes in the `java.io` package, and data structure related classes in the `java.util` package.

### “同一个包” vs. “不同的包”
### "Same Package" vs. "Different Package"

#### 同一个包 (Same Package)

当两个或多个类（或接口）在 Java 源代码文件中声明为属于相同的 `package` 时，它们被认为是“同一个包”的成员。

When two or more classes (or interfaces) are declared to belong to the same `package` in their Java source files, they are considered members of the "same package."

* **特征 (Characteristics):**
    * **文件系统结构：** 它们通常存储在文件系统的同一目录下，且该目录的名称与包名对应。
    * **File System Structure:** They are typically stored in the same directory in the file system, and the directory's name corresponds to the package name.
    * **访问权限：** 同一个包内的类可以互相访问它们的 `public`、`protected` 和 `默认`（包私有）成员。`private` 成员始终只能在定义它们的类内部访问。
    * **Access Rights:** Classes within the same package can access each other's `public`, `protected`, and `default` (package-private) members. `private` members remain accessible only within the class where they are defined.

#### 不同的包 (Different Package)

当两个或多个类（或接口）的 `package` 声明不同时，它们就属于“不同的包”。

When two or more classes (or interfaces) have different `package` declarations, they belong to "different packages."

* **特征 (Characteristics):**
    * **文件系统结构：** 它们通常存储在文件系统的不同目录下。
    * **File System Structure:** They are typically stored in different directories in the file system.
    * **使用方式：** 要在一个包中使用另一个包中的类，通常需要使用 `import` 语句（例如 `import com.example.myapp.MyClass;`）来引入，或者使用类的全限定名（例如 `com.example.myapp.MyClass myObject = new com.example.myapp.MyClass();`）。
    * **Usage:** To use a class from one package in another, you typically need to use an `import` statement (e.g., `import com.example.myapp.MyClass;`) or use the fully qualified name of the class (e.g., `com.example.myapp.MyClass myObject = new com.example.myapp.MyClass();`).
    * **访问权限：** 不同的包中的类只能访问对方的 `public` 成员。如果存在继承关系，子类即使在不同的包中，也可以访问父类的 `protected` 成员。
    * **Access Rights:** Classes in different packages can only access each other's `public` members. In an inheritance relationship, a subclass, even if in a different package, can also access its parent's `protected` members.

简而言之，包是 Java 中用于组织代码、管理命名空间和实现访问控制的基本单位。理解它们对于编写清晰、可维护和安全的 Java 代码至关重要。

In short, packages are fundamental units in Java for organizing code, managing namespaces, and implementing access control. Understanding them is crucial for writing clear, maintainable, and secure Java code.

