[TOC]
# 流式输入输出及文件处理
## 流式输入输出处理机制
我们来详细讲解一下 Java 中的**流式输入输出处理机制 (Stream I/O Processing Mechanism)**。这是 Java 语言处理数据传输的核心方式，无论是从文件、网络、内存还是其他程序，数据都以“流”的形式进行传输。

---

### Java 中的流式输入输出处理机制详解

在 Java 中，I/O（Input/Output）操作是基于“流 (Stream)”的概念。流可以被想象成连接数据源（Source）和数据目的地（Sink）的一条单向管道，数据在这条管道中顺序地流动。

Java 的 `java.io` 包提供了丰富的类来支持各种 I/O 操作。

#### 1. 流的本质与分类

**本质：**
* **抽象化：** Java I/O 流是对各种数据源和目的地的抽象。无论是读取文件、网络通信还是内存操作，都统一为流的概念，使得开发者可以用统一的 API 来处理不同来源/去向的数据。
* **单向性：** 流是单向的。如果需要同时进行输入和输出，你需要分别创建输入流和输出流。

**分类：**
Java 的流根据处理的数据类型和功能分为两大类：

**A. 根据数据单位：**

1.  **字节流 (Byte Streams)：**
    * 以字节（8位）为单位进行读写操作。
    * 适用于处理所有类型的数据，包括文本、图像、音频、视频等二进制数据。
    * **基类：** `InputStream` (抽象类，用于读取字节) 和 `OutputStream` (抽象类，用于写入字节)。
    * **常用子类：**
        * `FileInputStream` / `FileOutputStream`：用于读写文件中的字节。
        * `BufferedInputStream` / `BufferedOutputStream`：提供带缓冲的字节输入/输出，提高性能。
        * `DataInputStream` / `DataOutputStream`：用于读写 Java 基本数据类型（如 `int`, `double`, `boolean`）的二进制表示。
        * `ObjectInputStream` / `ObjectOutputStream`：用于对象的序列化和反序列化（将对象转换为字节序列存储，或将字节序列恢复为对象）。
        * `ByteArrayInputStream` / `ByteArrayOutputStream`：从/向内存中的字节数组读写数据。

2.  **字符流 (Character Streams)：**
    * 以字符（16位 Unicode 字符）为单位进行读写操作。
    * 适用于处理文本数据，能够正确处理各种字符编码（如 UTF-8, GBK 等），避免乱码问题。
    * **基类：** `Reader` (抽象类，用于读取字符) 和 `Writer` (抽象类，用于写入字符)。
    * **常用子类：**
        * `FileReader` / `FileWriter`：用于读写文件中的字符。它们使用平台默认的字符编码。
        * `BufferedReader` / `BufferedWriter`：提供带缓冲的字符输入/输出，提高性能，`BufferedReader` 提供了 `readLine()` 方法方便按行读取。
        * `InputStreamReader` / `OutputStreamWriter`：**字节流和字符流之间的桥梁**。它们将字节流转换为字符流，并在转换过程中处理字符编码（可以指定编码）。
        * `PrintWriter` / `PrintStream`：提供了方便的 `print()` 和 `println()` 方法，常用于输出文本到控制台或文件。`System.out` 就是一个 `PrintStream` 的实例。

**B. 根据功能/处理方式：**

1.  **节点流 (Node Streams / Low-Level Streams)：**
    * 直接与数据源或目的地（如文件、内存、网络连接）连接的流。它们是所有 I/O 操作的基础。
    * 例如：`FileInputStream`, `FileOutputStream`, `FileReader`, `FileWriter`。

2.  **处理流 / 过滤流 (Processing Streams / Filter Streams / High-Level Streams)：**
    * 封装（或“装饰”）在节点流之上，提供额外的功能或提高性能。它们本身不直接与数据源/目的地连接，而是通过其他流进行操作。
    * 例如：`BufferedInputStream` (在 `FileInputStream` 之上提供缓冲)、`DataInputStream` (在任何 `InputStream` 之上提供基本类型读写)。
    * 这种设计模式被称为**装饰器模式 (Decorator Pattern)**。

#### 2. 常用流的层次结构 (简化版)

**字节输入流：**
* `InputStream` (抽象基类)
    * `FileInputStream` (文件)
    * `ByteArrayInputStream` (字节数组)
    * `PipedInputStream` (管道)
    * `FilterInputStream` (抽象过滤流)
        * `BufferedInputStream` (缓冲)
        * `DataInputStream` (基本类型)
        * `ObjectInputStream` (对象)

**字节输出流：**
* `OutputStream` (抽象基类)
    * `FileOutputStream` (文件)
    * `ByteArrayOutputStream` (字节数组)
    * `PipedOutputStream` (管道)
    * `FilterOutputStream` (抽象过滤流)
        * `BufferedOutputStream` (缓冲)
        * `DataOutputStream` (基本类型)
        * `ObjectOutputStream` (对象)
        * `PrintStream` (打印流，如 `System.out`)

**字符输入流：**
* `Reader` (抽象基类)
    * `FileReader` (文件)
    * `StringReader` (字符串)
    * `CharArrayReader` (字符数组)
    * `InputStreamReader` (字节到字符的桥梁)
        * `FileReader` (实际上是 `InputStreamReader` 的子类，使用了默认编码)
    * `FilterReader` (抽象过滤流)
        * `BufferedReader` (缓冲)

**字符输出流：**
* `Writer` (抽象基类)
    * `FileWriter` (文件)
    * `StringWriter` (字符串)
    * `CharArrayWriter` (字符数组)
    * `OutputStreamWriter` (字符到字节的桥梁)
        * `FileWriter` (实际上是 `OutputStreamWriter` 的子类，使用了默认编码)
    * `FilterWriter` (抽象过滤流)
        * `BufferedWriter` (缓冲)
        * `PrintWriter` (打印流)

#### 3. 流操作的基本步骤

无论是哪种类型的流，其操作流程通常遵循以下三个基本步骤：

1.  **创建流对象 (Open the Stream)：**
    * 根据需要读写的数据源/目的地以及数据类型（字节/字符）选择合适的流类并创建其实例。
    * 例如：`FileInputStream fis = new FileInputStream("data.txt");`
    * 例如：`BufferedReader br = new BufferedReader(new FileReader("text.txt"));`

2.  **读写数据 (Read/Write Data)：**
    * 使用流对象提供的 `read()` (输入流) 或 `write()` (输出流) 方法进行数据传输。
    * `read()` 方法通常返回读取到的字节（0-255）或字符（0-65535），如果到达流的末尾则返回 -1。
    * `write()` 方法通常接收一个字节或字符作为参数。
    * 对于缓冲流，可能需要调用 `flush()` 方法将缓冲区中的数据强制写入目的地。

3.  **关闭流 (Close the Stream)：**
    * 这是**最关键**的一步。在使用完流之后，**必须**关闭它。
    * 关闭流会释放底层的系统资源（如文件句柄、网络端口），避免资源泄露。
    * 关闭操作通常在 `finally` 块中执行，或者更推荐地，使用 Java 7 引入的 **try-with-resources** 语句来自动关闭。
    * 关闭处理流时，它通常也会自动关闭其封装的底层节点流。

#### 4. 性能优化：缓冲流

直接读写单个字节或字符的效率很低，因为每次读写都可能涉及底层操作系统的调用和磁盘访问。为了提高 I/O 性能，Java 提供了**缓冲流**。

* **原理：** 缓冲流在内存中维护一个缓冲区（一个字节数组或字符数组）。
    * **输入缓冲：** 读数据时，它会一次性从底层流中读取一大块数据到缓冲区，然后每次从缓冲区中提供数据。当缓冲区为空时，再从底层流中批量读取。
    * **输出缓冲：** 写数据时，它会将数据先写入缓冲区，当缓冲区满时，再一次性将缓冲区中的数据写入到底层流。
* **常用类：**
    * `BufferedInputStream` / `BufferedOutputStream` (字节缓冲流)
    * `BufferedReader` / `BufferedWriter` (字符缓冲流)
* **用法：** 将节点流作为参数传递给缓冲流的构造器，形成一个链式结构。
    * 示例：`new BufferedReader(new FileReader("file.txt"))`
* **`flush()` 方法：** 对于输出缓冲流，当缓冲区未满但你需要确保数据已被写入目的地时（例如，在程序结束前），可以手动调用 `flush()` 方法。

#### 5. `java.nio` (New I/O) 包

除了传统的 `java.io` 包，Java 在 1.4 版本中引入了 `java.nio` (New I/O) 包，它提供了：
* **Channels (通道)：** 提供了更直接的、基于块的 I/O 操作，而不是传统的基于流的字节或字符读写。
* **Buffers (缓冲区)：** 与通道配合使用，提供内存块来存储数据。
* **Selectors (选择器)：** 用于实现多路复用 I/O，允许单个线程管理多个通道，适用于高性能网络应用。

`java.nio` 在某些高性能和非阻塞 I/O 场景下提供了更优的解决方案，但对于大多数常规文件 I/O 任务，`java.io` 仍然非常常用和方便。Java 7 的 `java.nio.file` 包进一步简化了文件系统操作。

#### 总结

Java 的流式输入输出处理机制提供了一套强大、灵活且可扩展的 API 来处理各种数据传输。通过理解字节流和字符流的区别、节点流和处理流的层叠关系，以及如何正确使用缓冲和关闭资源，开发者可以高效且安全地进行 I/O 操作。它是 Java 开发中不可或缺的一部分。

## java的输入输出流库
我们来对 Java 的输入输出流库进行一个简洁而全面的总结。

---

### Java 输入输出流库总结 (`java.io` 包)

Java 的 `java.io` 包提供了强大的、基于“流”概念的输入输出处理机制。它的核心思想是将数据传输抽象为从数据源到数据目的地流动的管道。

#### 1. 流的两个主要分类维度

1.  **按数据单位：**
    * **字节流 (Byte Streams):** 处理 8 位字节数据。适用于任何类型的数据（文本、图片、音频、视频等）。
        * 基类：`InputStream` (读) 和 `OutputStream` (写)。
        * 典型代表：`FileInputStream`, `FileOutputStream`, `BufferedInputStream`, `BufferedOutputStream`, `DataInputStream`, `DataOutputStream`, `ObjectInputStream`, `ObjectOutputStream`。
    * **字符流 (Character Streams):** 处理 16 位 Unicode 字符数据。**专门用于处理文本数据**，能够正确处理字符编码，避免乱码。
        * 基类：`Reader` (读) 和 `Writer` (写)。
        * 典型代表：`FileReader`, `FileWriter`, `BufferedReader`, `BufferedWriter`, `InputStreamReader` (字节转字符), `OutputStreamWriter` (字符转字节), `PrintWriter`。

2.  **按功能 / 角色：**
    * **节点流 (Node Streams / Low-Level Streams):** 直接与数据源（如文件、内存、网络连接）连接的流。它们是所有 I/O 操作的基础。
        * 例如：`FileInputStream`, `FileOutputStream`, `FileReader`, `FileWriter`, `ByteArrayInputStream`。
    * **处理流 / 过滤流 (Processing Streams / Filter Streams / High-Level Streams):** 封装（“装饰”）在节点流之上，提供额外的功能或提高性能。它们本身不直接连接数据源，而是通过其他流进行操作。
        * 例如：`BufferedInputStream` (提供缓冲), `DataInputStream` (读写基本数据类型), `ObjectInputStream` (对象序列化), `BufferedReader` (提供 `readLine()` 方法)。
        * 这种设计体现了**装饰器模式**。

#### 2. 流的核心操作和生命周期

无论哪种流，基本操作和生命周期管理是共通的：

1.  **打开 (Open):** 创建流对象，建立与数据源/目的地的连接。
    * `new FileInputStream("file.txt")`
2.  **读/写 (Read/Write):** 使用流对象的方法进行数据传输。
    * `read()`: 从输入流读取数据，返回一个字节/字符的 int 值或 -1 (流末尾)。
    * `write()`: 向输出流写入字节/字符。
    * `readLine()`: (仅 `BufferedReader`) 按行读取文本。
3.  **刷新 (Flush):** (仅输出缓冲流) 将缓冲区中尚未写入的数据强制写入目的地。
    * `bufferedWriter.flush()`
4.  **关闭 (Close):** 释放与流关联的所有系统资源（文件句柄、网络端口等）。**至关重要，防止资源泄露。**
    * `stream.close()`
    * **最佳实践：**
        * 在 `finally` 块中关闭流。
        * **推荐：** 使用 Java 7 引入的 **try-with-resources** 语句，实现资源的自动关闭，代码更简洁、安全。

#### 3. 字节流与字符流的转换

* 当需要从字节流读取文本数据或向字节流写入文本数据，并希望正确处理字符编码时，需要使用**转换流**：
    * `InputStreamReader`: 将字节输入流转换为字符输入流。可以指定字符集编码。
        * `new InputStreamReader(new FileInputStream("file.txt"), "UTF-8")`
    * `OutputStreamWriter`: 将字符输出流转换为字节输出流。可以指定字符集编码。
        * `new OutputStreamWriter(new FileOutputStream("file.txt"), "UTF-8")`

#### 4. 序列化与反序列化

* `ObjectInputStream` 和 `ObjectOutputStream` 用于将 Java 对象转换为字节序列（序列化）以便存储或传输，以及将字节序列恢复为 Java 对象（反序列化）。
* 被序列化的对象类必须实现 `java.io.Serializable` 接口（一个标记接口）。

#### 5. 性能优化

* **缓冲流 (Buffered Streams):** 通过在内存中设置缓冲区，减少底层 I/O 操作的次数，显著提高读写性能。这是最常用的性能优化手段。
    * `new BufferedReader(new FileReader("large.txt"))`
    * `new BufferedWriter(new FileWriter("output.txt"))`

#### 6. `java.nio` (New I/O) 概述

* 除了 `java.io`，Java 还提供了 `java.nio` 包，它提供了一种基于**通道 (Channels)** 和**缓冲区 (Buffers)** 的更高效、非阻塞的 I/O 机制。
* 适用于处理大量数据、需要高性能并发 I/O 或非阻塞 I/O 的场景（如服务器网络编程）。
* `java.nio.file` 包进一步简化了文件系统操作，提供了更现代的文件操作 API。

#### 总结图示 (简化)：

Java 的 I/O 流库庞大而灵活，通过层层封装和继承，提供了处理各种 I/O 场景的强大能力。理解其核心概念和分类，并掌握 `try-with-resources` 进行资源管理，是高效进行 Java I/O 编程的关键。
## 字节流
我们来详细讲解 Java 中的**字节流 (Byte Streams)**。

---

### Java 中的字节流 (Byte Streams) 详解

在 Java I/O 体系中，字节流是最基础的流类型，它以**字节（byte）**为单位进行数据传输。一个字节是 8 位二进制数据。由于计算机中的所有数据（无论是文本、图片、音频、视频还是程序代码）最终都是以字节的形式存储和传输的，因此字节流可以处理**任何类型**的数据。

#### 1. 字节流的基类

Java 中的所有字节流都继承自两个抽象基类：

1.  **`java.io.InputStream` (字节输入流)：**
    * 用于从数据源**读取**字节数据。
    * 核心方法：
        * `int read()`：从输入流中读取数据的下一个字节，返回一个 0 到 255 之间的整数表示该字节。如果已到达流的末尾，则返回 -1。
        * `int read(byte[] b)`：将最多 `b.length` 个字节从输入流读入一个字节数组中，返回实际读取的字节数。如果已到达流的末尾，则返回 -1。
        * `int read(byte[] b, int off, int len)`：将最多 `len` 个字节从输入流读入字节数组 `b` 中，从偏移量 `off` 处开始存放。
        * `void close()`：关闭输入流并释放与之关联的系统资源。

2.  **`java.io.OutputStream` (字节输出流)：**
    * 用于向数据目的地**写入**字节数据。
    * 核心方法：
        * `void write(int b)`：将指定的字节（由 `int` 值的低 8 位表示）写入输出流。
        * `void write(byte[] b)`：将 `b.length` 个字节从指定的字节数组写入输出流。
        * `void write(byte[] b, int off, int len)`：将 `len` 个字节从指定的字节数组写入输出流，从偏移量 `off` 处开始。
        * `void flush()`：刷新此输出流，强制任何缓冲的输出字节被写入。
        * `void close()`：关闭输出流并释放与之关联的系统资源。

#### 2. 常用字节流及其功能

字节流通常根据它们连接的数据源/目的地或提供的额外功能进行分类。

**A. 节点字节流 (直接与数据源/目的地连接)：**

1.  **`FileInputStream` / `FileOutputStream`：**
    * **功能：** 用于读写**文件**中的字节数据。
    * **特点：** 最常用的文件字节流，直接操作文件内容。
    * **示例：**
        ```java
        // 读取文件
        try (FileInputStream fis = new FileInputStream("input.jpg")) {
            int byteData;
            while ((byteData = fis.read()) != -1) {
                // 处理读取到的字节数据，例如写入另一个文件
                // System.out.println(byteData); // 打印字节的十进制表示
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 写入文件
        try (FileOutputStream fos = new FileOutputStream("output.bin")) {
            byte[] data = {0x48, 0x65, 0x6C, 0x6C, 0x6F}; // "Hello" 的 ASCII 码
            fos.write(data);
        } catch (IOException e) {
            e.printStackTrace();
        }
        ```

2.  **`ByteArrayInputStream` / `ByteArrayOutputStream`：**
    * **功能：** 用于从/向**内存中的字节数组**读写数据。
    * **特点：** 数据在内存中操作，不涉及外部文件或网络，速度快。
    * **示例：**
        ```java
        // 从字节数组读取
        byte[] inputBytes = {10, 20, 30, 40, 50};
        try (ByteArrayInputStream bais = new ByteArrayInputStream(inputBytes)) {
            int b;
            while ((b = bais.read()) != -1) {
                System.out.print(b + " ");
            } // 输出: 10 20 30 40 50
        } catch (IOException e) { /* 不会发生 */ }

        // 写入字节数组
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            baos.write(100);
            baos.write(200); // 实际写入的是 (byte)200，即 -56
            byte[] outputBytes = baos.toByteArray(); // 获取写入的字节数组
            System.out.println("\nWritten bytes length: " + outputBytes.length);
        } catch (IOException e) { /* 不会发生 */ }
        ```

3.  **`PipedInputStream` / `PipedOutputStream`：**
    * **功能：** 用于在**不同线程之间**通过管道传输字节数据。
    * **特点：** 生产者-消费者模式的简单实现，一个线程写入，另一个线程读取。

**B. 处理字节流 / 过滤字节流 (包装在其他流之上，提供额外功能)：**

1.  **`BufferedInputStream` / `BufferedOutputStream`：**
    * **功能：** 提供**缓冲**功能，提高 I/O 操作性能。它们会将数据先读入/写入内存缓冲区，减少实际底层 I/O 操作的次数。
    * **用法：** 包装一个节点流（如 `FileInputStream`）。
    * **示例：**
        ```java
        // 带缓冲的文件复制
        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream("source.txt"));
             BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("destination.txt"))) {
            int byteData;
            while ((byteData = bis.read()) != -1) {
                bos.write(byteData);
            }
            // bos.flush(); // BufferedOutputStream 在 close 时会自动 flush
        } catch (IOException e) {
            e.printStackTrace();
        }
        ```

2.  **`DataInputStream` / `DataOutputStream`：**
    * **功能：** 用于读写 Java **基本数据类型**（如 `int`, `double`, `boolean`, `String` 等）的二进制表示。
    * **特点：** 保证了数据类型在不同平台上的兼容性（如 `writeInt()` 总是写入 4 字节）。
    * **用法：** 包装一个字节流。
    * **示例：**
        ```java
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.dat"));
             DataInputStream dis = new DataInputStream(new FileInputStream("data.dat"))) {
            dos.writeInt(123);
            dos.writeDouble(3.14);
            dos.writeBoolean(true);
            dos.writeUTF("Hello World"); // UTF-8 编码的字符串

            int intVal = dis.readInt();
            double doubleVal = dis.readDouble();
            boolean boolVal = dis.readBoolean();
            String strVal = dis.readUTF();

            System.out.println("Read: " + intVal + ", " + doubleVal + ", " + boolVal + ", " + strVal);
        } catch (IOException e) {
            e.printStackTrace();
        }
        ```

3.  **`ObjectInputStream` / `ObjectOutputStream`：**
    * **功能：** 用于实现 Java 对象的**序列化 (Serialization)** 和**反序列化 (Deserialization)**。
    * **特点：** 可以将 Java 对象转换为字节序列进行存储或网络传输，再将字节序列恢复为对象。被序列化的对象类必须实现 `java.io.Serializable` 接口。
    * **示例：**
        ```java
        // 假设有一个 Student 类实现了 Serializable 接口
        // class Student implements Serializable { String name; int age; /* constructors, getters */ }

        // 序列化对象
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("student.ser"))) {
            // Student student = new Student("Alice", 20);
            // oos.writeObject(student);
            System.out.println("Object serialized.");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 反序列化对象
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("student.ser"))) {
            // Student student = (Student) ois.readObject();
            // System.out.println("Object deserialized: " + student.getName());
            System.out.println("Object deserialized.");
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        ```

4.  **`PrintStream`：**
    * **功能：** 提供打印各种数据类型的方法（`print()`, `println()`, `printf()`），常用于输出文本。
    * **特点：** 不抛出 `IOException`（内部捕获并设置错误标记）。`System.out` 就是一个 `PrintStream` 实例。

#### 3. 字节流的使用场景

* **文件复制、剪切：** 复制图片、视频、二进制文件等。
* **数据传输：** 网络通信中发送和接收原始字节数据。
* **内存操作：** 在内存中进行字节级别的读写和转换。
* **对象持久化：** 将 Java 对象序列化到文件或数据库。
* **加密/解密：** 对数据进行字节级别的加解密操作。

#### 4. 字节流的关闭与异常处理

* **资源关闭：** 任何打开的流都必须关闭，以释放系统资源。
    * **`finally` 块：** 在 `try-catch-finally` 结构中，在 `finally` 块中关闭流，确保无论是否发生异常都能关闭。
    * **`try-with-resources` (推荐)：** Java 7 及更高版本推荐使用，它能自动关闭实现了 `AutoCloseable` 接口的资源。

* **异常处理：** 字节流操作通常会抛出 `IOException` 及其子类，它们是**检查性异常**，必须被捕获或在方法签名中声明。

#### 总结

字节流是 Java I/O 的基石，能够处理所有类型的二进制数据。通过理解 `InputStream` 和 `OutputStream` 及其各种子类的功能和用法，结合缓冲流进行性能优化，并正确使用 `try-with-resources` 管理资源，可以高效且安全地进行各种 I/O 操作。在处理文本数据时，虽然字节流也能做到，但通常更推荐使用字符流，因为它能更好地处理字符编码问题。
## 文件
我们来详细讲解 Java 中的**文件 (File)** 操作。

---

### Java 中的文件操作详解

在 Java 中，对文件和目录的操作主要通过 `java.io.File` 类以及从 Java 7 开始引入的 `java.nio.file` 包（及其核心类 `Path` 和 `Files`）来完成。

#### 1. `java.io.File` 类

`java.io.File` 类是 Java 早期（传统 I/O）用于表示文件或目录的**抽象路径名**。它本身并不包含读写文件内容的方法，而是提供了一系列用于**文件和目录管理**的方法。

**主要功能：**

* **表示文件/目录路径：** 创建 `File` 对象只是在内存中抽象地表示一个路径，并不意味着文件或目录实际存在于文件系统中。
* **文件/目录属性查询：** 检查文件是否存在、是否是文件/目录、是否可读/写/执行、文件大小、最后修改时间等。
* **文件/目录操作：** 创建、删除、重命名文件或目录，列出目录内容等。

**构造器：**

* `File(String pathname)`: 根据给定的路径名字符串创建 `File` 对象。
``` java
File fileObject=new File(“d:/save/Hello.java”);
File dirObject=new File(“d:/save”);
```
* `File(String parent, String child)`: 根据父路径字符串和子路径字符串创建 `File` 对象。
 ``` java
File fileObject=new File(“d:/save”,”Hello.java”);
```
* `File(File parent, String child)`: 根据父 `File` 对象和子路径字符串创建 `File` 对象。
```java
File dirObject=new File(“d:/save”);
File fileObject=new File(dirObject,”Hello.java”);
```
**常用方法：**

| 方法签名                  | 描述                                                           | 返回类型/示例                                       |
| :------------------------ | :------------------------------------------------------------- | :-------------------------------------------------- |
| `boolean exists()`        | 测试文件或目录是否存在。                                       | `true` 或 `false`                                   |
| `boolean isDirectory()`   | 测试此抽象路径名表示的是否是目录。                             | `true` 或 `false`                                   |
| `boolean isFile()`        | 测试此抽象路径名表示的是否是文件。                             | `true` 或 `false`                                   |
| `String getName()`        | 返回此抽象路径名表示的文件或目录的名称字符串。                 | `"myFile.txt"`, `"myDir"`                           |
| `String getPath()`        | 返回此抽象路径名的路径字符串。                                 | `"path/to/myFile.txt"`                              |
| `String getAbsolutePath()`| 返回此抽象路径名的绝对路径字符串。                             | `"/Users/user/project/myFile.txt"`                |
| `File getParentFile()`    | 返回此抽象路径名父目录的抽象路径名。                           | `File` 对象 (表示父目录)                            |
| `long length()`           | 返回此抽象路径名表示的文件的长度（字节数）。如果路径不存在或为目录，则返回 0。 | `1024` (字节)                                       |
| `long lastModified()`     | 返回此抽象路径名表示的文件或目录的最后修改时间，以毫秒为单位。 | `1678886400000L`                                    |
| `boolean canRead()`       | 测试应用程序是否可以读取此抽象路径名表示的文件。               | `true` 或 `false`                                   |
| `boolean canWrite()`      | 测试应用程序是否可以修改此抽象路径名表示的文件。               | `true` 或 `false`                                   |
| `boolean createNewFile()` | 当且仅当不存在具有此抽象路径名指定名称的文件时，原子地创建该文件。 | `true` (创建成功) 或 `false` (文件已存在)             |
| `boolean delete()`        | 删除此抽象路径名表示的文件或目录。目录必须为空才能被删除。     | `true` (删除成功) 或 `false` (删除失败/文件不存在)    |
| `boolean mkdir()`         | 创建此抽象路径名指定的目录。                                   | `true` (创建成功) 或 `false` (创建失败/已存在)        |
| `boolean mkdirs()`        | 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。     | `true` (创建成功) 或 `false` (创建失败/已存在)        |
| `boolean renameTo(File dest)` | 重命名此抽象路径名表示的文件或目录。                       | `true` (重命名成功) 或 `false` (重命名失败)           |
| `String[] list()`         | 返回此抽象路径名表示的目录中的文件和目录的名称字符串数组。     | `{"file1.txt", "subdir", "file2.jpg"}`              |
| `File[] listFiles()`      | 返回此抽象路径名表示的目录中的文件和目录的抽象路径名数组。     | `File[]` 数组                                       |

**示例：**

```java
import java.io.File;
import java.io.IOException;

public class FileClassDemo {
    public static void main(String[] args) {
        String dirPath = "my_directory";
        String filePath = dirPath + File.separator + "my_file.txt"; // 使用 File.separator 保证跨平台兼容性

        File directory = new File(dirPath);
        File file = new File(filePath);

        // 1. 创建目录
        if (!directory.exists()) {
            if (directory.mkdirs()) { // mkdirs() 创建所有父目录
                System.out.println("Directory created: " + directory.getAbsolutePath());
            } else {
                System.out.println("Failed to create directory: " + directory.getAbsolutePath());
            }
        } else {
            System.out.println("Directory already exists: " + directory.getAbsolutePath());
        }

        // 2. 创建文件
        if (!file.exists()) {
            try {
                if (file.createNewFile()) { // createNewFile() 原子创建文件
                    System.out.println("File created: " + file.getName());
                } else {
                    System.out.println("Failed to create file: " + file.getName());
                }
            } catch (IOException e) {
                System.err.println("Error creating file: " + e.getMessage());
            }
        } else {
            System.out.println("File already exists: " + file.getName());
        }

        // 3. 获取文件信息
        if (file.exists()) {
            System.out.println("File name: " + file.getName());
            System.out.println("Absolute path: " + file.getAbsolutePath());
            System.out.println("Is file? " + file.isFile());
            System.out.println("Is directory? " + file.isDirectory());
            System.out.println("Can read? " + file.canRead());
            System.out.println("Can write? " + file.canWrite());
            System.out.println("File size (bytes): " + file.length());
            System.out.println("Last modified: " + new java.util.Date(file.lastModified()));
        }

        // 4. 列出目录内容
        if (directory.isDirectory()) {
            System.out.println("\nFiles in directory " + directory.getName() + ":");
            String[] fileNames = directory.list();
            if (fileNames != null) {
                for (String name : fileNames) {
                    System.out.println("- " + name);
                }
            }
        }

        // 5. 重命名文件 (可选：如果需要演示，可以取消注释)
        // File newFile = new File(dirPath + File.separator + "renamed_file.txt");
        // if (file.renameTo(newFile)) {
        //     System.out.println("\nFile renamed to: " + newFile.getName());
        // } else {
        //     System.out.println("\nFailed to rename file.");
        // }

        // 6. 删除文件 (可选：如果需要演示，可以取消注释)
        // if (file.exists()) {
        //     if (file.delete()) {
        //         System.out.println("\nFile deleted: " + file.getName());
        //     } else {
        //         System.out.println("\nFailed to delete file: " + file.getName());
        //     }
        // }

        // 7. 删除目录 (如果目录不为空，则不能直接删除，需要先删除其内部文件)
        // if (directory.exists() && directory.isDirectory()) {
        //     if (directory.delete()) {
        //         System.out.println("Directory deleted: " + directory.getName());
        //     } else {
        //         System.out.println("Failed to delete directory (might not be empty): " + directory.getName());
        //     }
        // }
    }
}
```

#### 2. `java.nio.file` 包 (NIO.2)

从 Java 7 开始，`java.nio.file` 包提供了更现代、更强大的文件系统操作 API，解决了 `java.io.File` 在某些方面（如异常处理、符号链接、原子操作、文件属性操作）的不足。

**核心类：**

* **`Path`：** 抽象和表示文件系统中的路径。它比 `File` 更强大，因为它专注于路径本身，而不是文件/目录的实体。
    * 创建：`Paths.get("path/to/file.txt")` 或 `Paths.get("parent", "child")`。
* **`Files`：** 一个静态工具类，提供了大量用于文件和目录操作的静态方法。这些方法通常返回 `Path` 对象，并以 `Path` 对象作为参数。

**`Files` 类的常用方法 (部分)：**

* `Files.exists(Path path)`: 检查路径是否存在。
* `Files.isDirectory(Path path)`: 检查是否是目录。
* `Files.isRegularFile(Path path)`: 检查是否是常规文件。
* `Files.createFile(Path path)`: 创建新文件。
* `Files.createDirectory(Path dir)`: 创建新目录。
* `Files.createDirectories(Path dir)`: 创建目录及其所有不存在的父目录。
* `Files.delete(Path path)`: 删除文件或空目录。
* `Files.deleteIfExists(Path path)`: 如果存在则删除文件或空目录。
* `Files.copy(Path source, Path target, CopyOption... options)`: 复制文件。
* `Files.move(Path source, Path target, CopyOption... options)`: 移动/重命名文件。
* `Files.readAllBytes(Path path)`: 读取文件所有字节到字节数组。
* `Files.readAllLines(Path path)`: 读取所有文本行到 `List<String>`。
* `Files.write(Path path, byte[] bytes, OpenOption... options)`: 写入字节到文件。
* `Files.write(Path path, Iterable<? extends CharSequence> lines, Charset cs, OpenOption... options)`: 写入文本行到文件。
* `Files.walk(Path start, FileVisitOption... options)`: 遍历文件树。

**示例 (使用 `java.nio.file`)：**

```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.List;
import java.util.Arrays;
import java.nio.charset.StandardCharsets; // 明确指定字符编码

public class NIO2FileDemo {
    public static void main(String[] args) {
        Path dirPath = Paths.get("my_nio_directory");
        Path filePath = dirPath.resolve("my_nio_file.txt"); // 更现代的路径拼接方式

        try {
            // 1. 创建目录
            if (!Files.exists(dirPath)) {
                Files.createDirectories(dirPath); // 创建目录及其所有父目录
                System.out.println("Directory created: " + dirPath.toAbsolutePath());
            } else {
                System.out.println("Directory already exists: " + dirPath.toAbsolutePath());
            }

            // 2. 创建文件
            if (!Files.exists(filePath)) {
                Files.createFile(filePath); // 原子创建文件
                System.out.println("File created: " + filePath.getFileName());
            } else {
                System.out.println("File already exists: " + filePath.getFileName());
            }

            // 3. 写入文件
            List<String> lines = Arrays.asList("Hello, NIO.2!", "This is a new line.", "你好，世界！");
            Files.write(filePath, lines, StandardCharsets.UTF_8,
                        StandardOpenOption.APPEND); // 追加写入，并指定UTF-8编码
            System.out.println("Content written to file.");

            // 4. 读取文件
            System.out.println("\nReading file content:");
            List<String> readLines = Files.readAllLines(filePath, StandardCharsets.UTF_8);
            for (String line : readLines) {
                System.out.println(line);
            }

            // 5. 文件复制
            Path copiedFilePath = Paths.get(dirPath.toString(), "my_nio_file_copy.txt");
            Files.copy(filePath, copiedFilePath, java.nio.file.StandardCopyOption.REPLACE_EXISTING);
            System.out.println("\nFile copied to: " + copiedFilePath.getFileName());

            // 6. 删除文件 (可选：如果需要演示，可以取消注释)
            // Files.delete(filePath); // 如果文件不存在会抛异常
            // Files.deleteIfExists(copiedFilePath); // 如果文件不存在则不抛异常
            // System.out.println("\nFiles deleted.");

            // 7. 删除目录 (如果目录不为空，则不能直接删除，需要先删除其内部文件)
            // Files.delete(dirPath); // 如果目录不为空会抛异常
            // System.out.println("Directory deleted.");

        } catch (IOException e) {
            System.err.println("An I/O error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

#### 总结和推荐

* **`java.io.File`：** 更适用于**文件/目录属性查询和基本管理**。在 Java 7 之前是操作文件系统的主力。它的方法通常返回 `boolean` 类型，操作失败时不易获取详细错误信息。
* **`java.nio.file` (NIO.2)：**
    * **推荐用于现代 Java 应用的文件和目录操作。**
    * 提供了更强大、更灵活、更安全的 API。
    * `Path` 类更清晰地表示路径，`Files` 类提供了原子操作、更好的异常处理机制和丰富的工具方法。
    * 明确支持指定字符编码，减少乱码问题。
    * 在处理文件读写内容时，通常会结合 `java.io` 包中的流（如 `BufferedReader`/`BufferedWriter`）来使用，或者使用 `Files` 类提供的便利方法（如 `readAllLines`, `write`）。

选择哪个 API 取决于具体需求，但对于新的项目和更复杂的场景，强烈建议优先使用 `java.nio.file` 包。


-------
我们来详细讲解 Java 中的**随机文件访问：`RandomAccessFile` 类**。


### Java 中的随机文件访问：`RandomAccessFile` 类详解

在 Java 的 `java.io` 包中，`RandomAccessFile` 类是一个非常独特的类，它既不是 `InputStream` 的子类，也不是 `OutputStream` 的子类，但它同时实现了 `DataInput` 和 `DataOutput` 接口。这使得 `RandomAccessFile` 拥有了强大的功能：它允许你在文件的**任何位置**进行读写操作，而不是像普通流那样只能顺序读写。

#### 1. `RandomAccessFile` 的特性

1.  **随机访问：** 这是它最核心的特点。你可以自由地在文件中跳跃到任意字节位置进行读写。这通过 `seek()` 方法实现。
2.  **同时支持读和写：** 一个 `RandomAccessFile` 对象可以同时进行读和写操作，无需像 `FileInputStream` 和 `FileOutputStream` 那样需要分别创建输入流和输出流。
3.  **基于字节操作：** 尽管它提供了读写基本数据类型的方法（通过实现 `DataInput` 和 `DataOutput` 接口），但其底层仍然是基于字节进行操作的。
4.  **不属于标准流体系：** 它不继承 `InputStream` 或 `OutputStream`，这意味着你不能直接将它作为参数传递给需要 `InputStream` 或 `OutputStream` 的方法（例如 `BufferedInputStream`）。
5.  **文件指针 (File Pointer)：** `RandomAccessFile` 内部维护一个文件指针，指示当前读写操作的位置。每次读写后，文件指针会自动向前移动。

#### 2. `RandomAccessFile` 的构造器

创建 `RandomAccessFile` 对象时，需要指定文件路径和访问模式。

* `RandomAccessFile(File file, String mode)`
* `RandomAccessFile(String name, String mode)`

**访问模式 (mode)：**

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `"r"` | **只读 (read)**。打开文件进行读取。如果文件不存在，则抛出 `FileNotFoundException`。 |
| `"rw"` | **读写 (read/write)**。打开文件进行读写。如果文件不存在，则尝试创建文件。 |
| `"rws"` | **读写并同步文件内容的更新 (read/write with synchronous writes)**。除了 `"rw"` 的功能外，还要求对文件内容或元数据的每个更新都立即写入到底层存储设备。 |
| `"rwd"` | **读写并同步文件内容的更新，不包括元数据 (read/write with synchronous writes to file content)**。除了 `"rw"` 的功能外，要求对文件内容的每个更新都立即写入到底层存储设备。元数据（如文件大小、最后修改时间）的更新可能不会立即写入。 |

通常，我们使用 `"r"` 或 `"rw"` 模式。`"rws"` 和 `"rwd"` 主要用于需要高数据完整性保障（如数据库日志）的特殊场景，性能开销较大。

#### 3. `RandomAccessFile` 的常用方法

| 方法签名                 | 描述                                                                    | 返回类型/示例                                  |
| :----------------------- | :---------------------------------------------------------------------- | :--------------------------------------------- |
| `long getFilePointer()`  | 返回文件指针的当前位置（字节偏移量）。                                  | `long` (当前位置)                              |
| `void seek(long pos)`    | 将文件指针设置到指定位置（从文件开头算起的字节偏移量）。               | `void`                                         |
| `long length()`          | 返回此文件的长度（字节数）。                                            | `long` (文件大小)                              |
| `void setLength(long newLength)` | 设置此文件的长度。如果 `newLength` 小于当前长度，则截断文件；如果大于当前长度，则扩展文件。 | `void`                                         |
| `int read()`             | 从文件中读取一个字节，返回 0 到 255 之间的整数。到达文件末尾返回 -1。 | `int`                                          |
| `int read(byte[] b)`     | 从文件中读取最多 `b.length` 个字节到字节数组 `b` 中。返回读取的字节数。 | `int`                                          |
| `void write(int b)`      | 将指定的字节写入文件。                                                  | `void`                                         |
| `void write(byte[] b)`   | 将 `b.length` 个字节从字节数组 `b` 写入文件。                           | `void`                                         |
| `void write(byte[] b, int off, int len)` | 将 `len` 个字节从字节数组 `b` 写入文件，从偏移量 `off` 处开始。       | `void`                                         |
| `String readLine()`      | 从文件中读取一行文本。**注意：此方法已过时且不推荐，因为不支持 Unicode。** | `String` (行内容)                              |
| `String readUTF()`       | 从文件中读取一个 UTF-8 编码的字符串。                                 | `String`                                       |
| `void writeUTF(String str)` | 将一个 UTF-8 编码的字符串写入文件。                                   | `void`                                         |
| `int readInt()`          | 从文件中读取一个 4 字节的整数。                                         | `int`                                          |
| `void writeInt(int v)`   | 将一个 4 字节的整数写入文件。                                           | `void`                                         |
| ... (其他基本类型读写方法) | `readLong()`, `writeLong()`, `readDouble()`, `writeDouble()`, `readBoolean()`, `writeBoolean()` 等。 | 对应类型                                       |
| `void close()`           | 关闭文件并释放相关资源。                                                | `void`                                         |

#### 4. `RandomAccessFile` 的应用场景

`RandomAccessFile` 最适合以下场景：

* **大数据文件处理：** 当文件非常大，无法一次性加载到内存中时，可以使用 `RandomAccessFile` 跳转到特定位置进行读写。
* **数据库文件操作：** 某些简单的数据库或索引文件可能使用 `RandomAccessFile` 来实现记录的定位和修改。
* **文件分块下载/上传：** 下载或上传文件时，可以同时进行多线程分块操作，每个线程负责文件的不同部分。
* **更新文件特定部分：** 例如，修改日志文件中的某个标记位，或者更新大型数据文件中的某条记录，而无需读取整个文件。
* **内存映射文件 (Memory-Mapped Files) 的替代：** 在 NIO `MappedByteBuffer` 出现之前，`RandomAccessFile` 是实现类似功能的唯一选择。

#### 5. 示例：使用 `RandomAccessFile` 进行文件读写和定位

```java
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.charset.StandardCharsets; // 导入标准字符集

public class RandomAccessFileDemo {

    private static final String FILE_NAME = "random_access_demo.txt";

    public static void main(String[] args) {
        // 确保文件不存在，方便演示从头开始
        File file = new File(FILE_NAME);
        if (file.exists()) {
            file.delete();
            System.out.println("Existing file " + FILE_NAME + " deleted.");
        }

        System.out.println("--- 写入文件 ---");
        try (RandomAccessFile raf = new RandomAccessFile(FILE_NAME, "rw")) {
            // 写入一些文本数据
            raf.write("Hello World\n".getBytes(StandardCharsets.UTF_8)); // 写入UTF-8编码字节
            raf.write("Java is awesome\n".getBytes(StandardCharsets.UTF_8));

            // 获取当前文件指针位置
            long currentPos = raf.getFilePointer();
            System.out.println("Current position after writing: " + currentPos + " bytes.");

            // 写入一个整数
            raf.writeInt(12345);
            System.out.println("Current position after writing int: " + raf.getFilePointer() + " bytes.");

            // 写入一个字符串 (使用 writeUTF 确保编码一致性)
            raf.writeUTF("End of File Data.");
            System.out.println("Current position after writing UTF string: " + raf.getFilePointer() + " bytes.");

            System.out.println("Total file length: " + raf.length() + " bytes.");

        } catch (IOException e) {
            System.err.println("Error during writing: " + e.getMessage());
            e.printStackTrace();
        }

        System.out.println("\n--- 读取文件 ---");
        try (RandomAccessFile raf = new RandomAccessFile(FILE_NAME, "r")) {
            // 1. 读取第一行
            String line1 = raf.readLine(); // 注意：readLine() 已过时且不支持UTF-8，这里仅为演示
            System.out.println("Read Line 1 (using readLine): " + line1);
            System.out.println("Position after reading Line 1: " + raf.getFilePointer());

            // 2. 跳过下一行，直接跳到某个特定位置
            // 假设我们知道 "Java is awesome\n" 是 16个字节 (如果按UTF-8计算，中文会是3个字节)
            // 简单演示跳过，实际需要更精确的字节计算
            // raf.skipBytes(16); // 跳过16个字节

            // 3. 将文件指针设置到文件的开头
            raf.seek(0);
            System.out.println("\nSeeked to beginning. Current position: " + raf.getFilePointer());

            // 4. 再次读取第一行 (使用更安全的字节读取，并手动解码)
            byte[] buffer = new byte[20]; // 足够容纳第一行
            int bytesRead = raf.read(buffer); // 读取到缓冲区
            if (bytesRead != -1) {
                System.out.println("Read (bytes): " + new String(buffer, 0, bytesRead, StandardCharsets.UTF_8).trim());
            }
            System.out.println("Position after reading bytes: " + raf.getFilePointer());

            // 5. 再次定位到写入整数的位置 (假设之前写入的整数在某个固定偏移量)
            // 假设 "Hello World\n" 是 12 bytes, "Java is awesome\n" 是 16 bytes
            // 那么整数从 12 + 16 = 28 字节开始
            raf.seek(28); // 定位到整数开始的字节位置
            System.out.println("\nSeeked to integer position. Current position: " + raf.getFilePointer());
            int readInt = raf.readInt(); // 读取整数
            System.out.println("Read Integer: " + readInt);
            System.out.println("Position after reading integer: " + raf.getFilePointer());

            // 6. 读取 UTF 字符串
            String readUTFStr = raf.readUTF();
            System.out.println("Read UTF String: " + readUTFStr);
            System.out.println("Position after reading UTF string: " + raf.getFilePointer());

            // 7. 定位到文件末尾，尝试写入（这会追加内容）
            raf.seek(raf.length());
            raf.write("Appended content.\n".getBytes(StandardCharsets.UTF_8));
            System.out.println("\nAppended content. New file length: " + raf.length());

        } catch (IOException e) {
            System.err.println("Error during reading: " + e.getMessage());
            e.printStackTrace();
        }

        // 清理文件 (可选)
        // if (file.exists()) {
        //     file.delete();
        //     System.out.println("\nCleaned up: " + FILE_NAME);
        // }
    }
}
```

#### 6. 注意事项

* **编码问题：** `readLine()` 方法在 `RandomAccessFile` 中是过时的，因为它不支持字符编码，可能导致中文乱码。如果需要读写文本，最好使用 `read(byte[])` 和 `write(byte[])`，然后手动进行字节到字符串的编码/解码（如使用 `String` 的构造器和 `getBytes()` 方法并指定字符集）。`readUTF()` 和 `writeUTF()` 专门处理 UTF-8 编码的字符串。
* **性能：** 对于大量连续的顺序读写，传统的缓冲流 (`BufferedInputStream`/`BufferedOutputStream`) 通常比 `RandomAccessFile` 效率更高。`RandomAccessFile` 的优势在于随机定位。
* **异常处理：** `RandomAccessFile` 的操作同样会抛出 `IOException`，需要进行适当的异常处理，并确保在使用完毕后关闭文件。推荐使用 `try-with-resources` 语句。
* **并发访问：** `RandomAccessFile` 不是线程安全的。如果多线程需要访问同一个文件，需要自行进行同步控制（例如使用 `synchronized` 关键字或 `java.nio.channels.FileLock`）。

`RandomAccessFile` 是 Java I/O 中一个非常强大但相对底层和专业的工具，掌握它能够解决许多复杂的、需要精确文件定位和修改的场景。

----
## 字符流
我们来详细讲解 Java 中的**字符流 (Character Streams)**。

### Java 中的字符流 (Character Streams) 详解

在 Java I/O 体系中，字符流是专门用于处理**文本数据**的流类型。它以**字符（Character）**为单位进行读写操作，每个字符占用 16 位（一个 Unicode 字符）。相较于字节流，字符流的优势在于它能够正确处理各种字符编码（如 UTF-8, GBK, UTF-16 等），从而有效避免在处理文本时出现的乱码问题。

#### 1. 字符流的基类

Java 中的所有字符流都继承自两个抽象基类：

1.  **`java.io.Reader` (字符输入流)：**
    * 用于从数据源**读取**字符数据。
    * 核心方法：
        * `int read()`：从输入流中读取数据的下一个字符，返回一个 0 到 65535 之间的整数表示该字符。如果已到达流的末尾，则返回 -1。
        * `int read(char[] cbuf)`：将最多 `cbuf.length` 个字符从输入流读入一个字符数组中，返回实际读取的字符数。如果已到达流的末尾，则返回 -1。
        * `int read(char[] cbuf, int off, int len)`：将最多 `len` 个字符从输入流读入字符数组 `cbuf` 中，从偏移量 `off` 处开始存放。
        * `void close()`：关闭输入流并释放与之关联的系统资源。

2.  **`java.io.Writer` (字符输出流)：**
    * 用于向数据目的地**写入**字符数据。
    * 核心方法：
        * `void write(int c)`：将指定的字符（由 `int` 值的低 16 位表示）写入输出流。
        * `void write(char[] cbuf)`：将 `cbuf.length` 个字符从指定的字符数组写入输出流。
        * `void write(char[] cbuf, int off, int len)`：将 `len` 个字符从指定的字符数组写入输出流，从偏移量 `off` 处开始。
        * `void write(String str)`：将字符串写入输出流。
        * `void write(String str, int off, int len)`：将字符串的某个子串写入输出流。
        * `void flush()`：刷新此输出流，强制任何缓冲的输出字符被写入。
        * `void close()`：关闭输出流并释放与之关联的系统资源。

#### 2. 常用字符流及其功能

字符流通常根据它们连接的数据源/目的地或提供的额外功能进行分类。

**A. 节点字符流 (直接与数据源/目的地连接)：**

1.  **`FileReader` / `FileWriter`：**
    * **功能：** 用于读写**文件**中的字符数据。
    * **特点：** 它们是 `InputStreamReader` 和 `OutputStreamWriter` 的便利子类，内部使用了平台默认的字符编码。这意味着在不同操作系统上，如果文件编码与平台默认编码不一致，可能会出现乱码。**在生产环境中处理文件时，通常建议使用 `InputStreamReader`/`OutputStreamWriter` 显式指定编码。**
    * **示例：**
        ```java
        // 写入文件 (使用平台默认编码)
        try (FileWriter writer = new FileWriter("output.txt")) {
            writer.write("Hello 字符流！\n");
            writer.write("Java character streams.");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 读取文件 (使用平台默认编码)
        try (FileReader reader = new FileReader("output.txt")) {
            int charData;
            while ((charData = reader.read()) != -1) {
                System.out.print((char) charData);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        ```

2.  **`StringReader` / `StringWriter`：**
    * **功能：** 用于从/向**内存中的字符串**读写数据。
    * **特点：** 方便在内存中进行字符串操作，不涉及外部资源。
    * **示例：**
        ```java
        // 从字符串读取
        String sourceString = "这是内存中的字符串数据。";
        try (StringReader sr = new StringReader(sourceString)) {
            int c;
            while ((c = sr.read()) != -1) {
                System.out.print((char) c);
            }
        } catch (IOException e) { /* 不会发生 */ }

        // 写入字符串
        try (StringWriter sw = new StringWriter()) {
            sw.write("写入到 StringWriter。");
            String result = sw.toString(); // 获取写入的字符串
            System.out.println("\nWritten to StringWriter: " + result);
        } catch (IOException e) { /* 不会发生 */ }
        ```

3.  **`CharArrayReader` / `CharArrayWriter`：**
    * **功能：** 用于从/向**内存中的字符数组**读写数据。

**B. 转换流 (字节流与字符流之间的桥梁)：**

1.  **`InputStreamReader` / `OutputStreamWriter`：**
    * **功能：** 它们是字节流和字符流之间的**桥梁**。
        * `InputStreamReader` 将字节输入流 (`InputStream`) 转换为字符输入流 (`Reader`)。
        * `OutputStreamWriter` 将字符输出流 (`Writer`) 转换为字节输出流 (`OutputStream`)。
    * **特点：** **可以在构造器中指定字符编码**，这是它们最核心的价值，从而解决跨平台或特定编码的文本乱码问题。
    * **示例：**
        ```java
        import java.nio.charset.StandardCharsets; // 导入标准字符集

        // 写入文件 (指定 UTF-8 编码)
        try (OutputStreamWriter osw = new OutputStreamWriter(
                new FileOutputStream("output_utf8.txt"), StandardCharsets.UTF_8)) {
            osw.write("Hello 编码！\n");
            osw.write("这是一个UTF-8编码的文本。");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 读取文件 (指定 UTF-8 编码)
        try (InputStreamReader isr = new InputStreamReader(
                new FileInputStream("output_utf8.txt"), StandardCharsets.UTF_8)) {
            int charData;
            while ((charData = isr.read()) != -1) {
                System.out.print((char) charData);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        ```

**C. 处理字符流 / 过滤字符流 (包装在其他流之上，提供额外功能)：**

1.  **`BufferedReader` / `BufferedWriter`：**
    * **功能：** 提供**缓冲**功能，显著提高字符 I/O 操作性能。
    * **特点：** `BufferedReader` 提供了方便的 `readLine()` 方法，可以按行读取文本。`BufferedWriter` 需要手动 `flush()` 来确保数据写入。
    * **用法：** 包装一个节点流或转换流。
    * **示例：**
        ```java
        // 带缓冲的按行读取文件 (通常结合 InputStreamReader 指定编码)
        try (BufferedReader br = new BufferedReader(
                new InputStreamReader(new FileInputStream("output_utf8.txt"), StandardCharsets.UTF_8))) {
            String line;
            System.out.println("\n--- 按行读取文件内容 ---");
            while ((line = br.readLine()) != null) { // 按行读取
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 带缓冲的写入文件
        try (BufferedWriter bw = new BufferedWriter(
                new OutputStreamWriter(new FileOutputStream("buffered_output.txt"), StandardCharsets.UTF_8))) {
            bw.write("第一行文本。");
            bw.newLine(); // 写入一个平台相关的换行符
            bw.write("第二行文本。");
            bw.flush(); // 强制将缓冲区内容写入文件
        } catch (IOException e) {
            e.printStackTrace();
        }
        ```

2.  **`PrintWriter`：**
    * **功能：** 提供了各种方便的 `print()`, `println()`, `printf()` 方法，可以直接打印基本数据类型、对象和格式化字符串到输出流。
    * **特点：** * **可以自动刷新 (autoflush)：** 在创建时可以指定 `true`，使得每次调用 `println()`、`printf()` 或格式化 `write()` 后自动刷新输出流。
        * **不抛出 `IOException`：** 内部捕获并设置错误标记，可以通过 `checkError()` 方法检查是否有错误发生。
    * **用法：** 包装一个 `Writer` 或 `OutputStream`。
    * **示例：**
        ```java
        try (PrintWriter pw = new PrintWriter(new FileWriter("print_output.txt"), true)) { // true 表示自动刷新
            pw.println("这是一个打印文本的例子。");
            pw.printf("数值: %d, 浮点数: %.2f%n", 123, 45.678);
            pw.print("没有换行符。");
            // 因为设置了自动刷新，所以每行都会立即写入
        } catch (IOException e) {
            e.printStackTrace();
        }
        ```

#### 3. 字符流的使用场景

* **读写文本文件：** 配置文件、日志文件、源代码文件、CSV 文件等。
* **网络文本通信：** HTTP 请求/响应体、聊天程序等。
* **控制台输入输出：** `System.in` 和 `System.out` 的底层处理。
* **字符串处理：** 在内存中对字符串进行高效读写操作。

#### 4. 字符流的关闭与异常处理

* **资源关闭：** 任何打开的流都必须关闭，以释放系统资源。
    * **`finally` 块：** 在 `try-catch-finally` 结构中，在 `finally` 块中关闭流，确保无论是否发生异常都能关闭。
    * **`try-with-resources` (推荐)：** Java 7 及更高版本推荐使用，它能自动关闭实现了 `AutoCloseable` 接口的资源。

* **异常处理：** 字符流操作通常会抛出 `IOException` 及其子类，它们是**检查性异常**，必须被捕获或在方法签名中声明。

#### 总结

字符流是 Java I/O 中处理文本数据的首选方案。它解决了字节流在处理字符编码时可能遇到的乱码问题。通过理解 `Reader` 和 `Writer` 及其各种子类的功能和用法，特别是**转换流**（`InputStreamReader` / `OutputStreamWriter`）在处理编码时的关键作用，结合缓冲流进行性能优化，并正确使用 `try-with-resources` 管理资源，可以高效且安全地进行各种文本 I/O 操作。
## 标准输入输出
好的，我们来详细讲解 Java 中的**标准输入输出 (Standard Input/Output)**。

---

### Java 中的标准输入输出 (Standard Input/Output) 详解

在 Java 中，标准输入输出指的是程序与外部世界进行最基本交互的方式，通常是指与**控制台 (Console)** 的交互。Java 通过 `java.lang.System` 类提供了三个预定义的 `Stream` 对象，代表了这三种标准 I/O 通道：

1.  **`System.in`：** 标准输入流 (Standard Input Stream)
2.  **`System.out`：** 标准输出流 (Standard Output Stream)
3.  **`System.err`：** 标准错误流 (Standard Error Stream)

这三个流都是 `public static final` 成员变量，可以直接通过 `System` 类访问。

#### 1. `System.in` (标准输入流)

* **类型：** `java.io.InputStream`
* **作用：** 用于从标准输入设备（通常是键盘）读取数据。
* **特点：**
    * 它是字节流，因此直接使用 `System.in.read()` 只能读取单个字节。
    * 它提供的是原始字节输入，不适合直接读取文本、数字等结构化数据。
    * 通常需要将其包装在其他流或工具类中，以便进行更方便的文本或基本数据类型读取。

**常用包装方式：**

a. **使用 `Scanner` 类 (推荐用于读取用户输入)：**
    * `java.util.Scanner` 是一个功能强大的文本扫描器，可以解析基本数据类型和字符串。
    * 它是 Java 5 引入的，极大简化了从控制台读取输入的复杂性。
    * `Scanner` 会处理字符编码和数据类型转换。

```java
    import java.util.InputMismatchException; // 导入可能的异常
    import java.util.Scanner;

    public class StandardInputDemo {
        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in); // 将 System.in 包装到 Scanner 中

            System.out.print("请输入你的名字：");
            String name = scanner.nextLine(); // 读取一行字符串，包括空格
            System.out.println("你的名字是：" + name);

            System.out.print("请输入你的年龄（整数）：");
            try {
                int age = scanner.nextInt(); // 读取一个整数
                System.out.println("你的年龄是：" + age);
            } catch (InputMismatchException e) {
                System.err.println("错误：请输入一个有效的整数！");
                scanner.next(); // 消费掉错误的输入，避免无限循环
            }

            scanner.close(); // 关闭 Scanner，释放资源。
                            // 注意：关闭 System.in 可能影响同一JVM中其他需要输入的地方
        }
    }
```

b. **使用 `BufferedReader` (传统方式，更适合高效行读取)：**
    * 需要将 `System.in` 转换为字符流 `InputStreamReader`，然后进一步包装到 `BufferedReader` 中以支持 `readLine()` 方法。
    * 适用于需要高效按行读取大量文本数据的情况。

```java
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;

    public class StandardInputBufferedReaderDemo {
        public static void main(String[] args) {
            // 将字节流 System.in 包装成字符流，并指定字符编码
            // 再用 BufferedReader 包装，以提供 readLine() 方法和缓冲
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

            System.out.print("请输入一句话：");
            String line = null;
            try {
                line = reader.readLine(); // 读取一行文本
                System.out.println("你输入的是：" + line);
            } catch (IOException e) {
                System.err.println("读取输入时发生错误：" + e.getMessage());
            } finally {
                // 通常不关闭 System.in，除非程序即将结束
                // 如果是包装了其他流，如文件流，则需要在此处关闭
                // try {
                //     if (reader != null) reader.close();
                // } catch (IOException e) {
                //     e.printStackTrace();
                // }
            }
        }
    }
```

#### 2. `System.out` (标准输出流)

* **类型：** `java.io.PrintStream`
* **作用：** 用于向标准输出设备（通常是控制台）打印数据。
* **特点：**
    * `PrintStream` 是一个字节输出流，但它提供了方便的 `print()` 和 `println()` 方法，可以直接输出各种基本数据类型、对象和字符串。
    * 它不抛出 `IOException`（内部捕获并设置错误标记），使用起来非常方便。
    * `println()` 方法在打印内容后会自动添加换行符。

**常用方法：**

* `System.out.print(data)`: 打印数据，不换行。
* `System.out.println(data)`: 打印数据，并在末尾添加换行符。
* `System.out.printf(format, args)`: 使用格式化字符串打印数据（Java 5 引入，类似于 C 语言的 `printf`）。

**示例：**

```java
public class StandardOutputDemo {
    public static void main(String[] args) {
        System.out.print("Hello, "); // 不换行
        System.out.println("World!"); // 换行

        int number = 123;
        double price = 45.678;
        String product = "Laptop";

        System.out.println("Number: " + number);
        System.out.println("Product: " + product + ", Price: " + price);

        // 使用 printf 进行格式化输出
        System.out.printf("Product: %s, Price: %.2f, Quantity: %d%n", product, price, 5);
        // %s: 字符串，%.2f: 浮点数保留两位小数，%d: 整数，%n: 平台无关的换行符
    }
}
```

#### 3. `System.err` (标准错误流)

* **类型：** `java.io.PrintStream`
* **作用：** 用于向标准错误设备（通常也是控制台，但可以被重定向）打印错误信息。
* **特点：**
    * 与 `System.out` 类似，也是 `PrintStream` 类型，提供 `print()` 和 `println()` 方法。
    * 它通常用于输出程序的错误、警告或调试信息，以便与正常的程序输出区分开来。
    * 在许多操作系统中，标准输出和标准错误可以被独立重定向，这使得开发者可以将程序的正常输出和错误信息分别记录到不同的地方。

**示例：**

```java
public class StandardErrorDemo {
    public static void main(String[] args) {
        System.out.println("这是程序的正常输出。"); // 输出到标准输出

        // 模拟一个错误情况
        int divisor = 0;
        try {
            int result = 10 / divisor;
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.err.println("发生了一个错误：除数不能为零！"); // 错误信息输出到标准错误
            System.err.println("错误详情：" + e.getMessage()); // 错误详情
            e.printStackTrace(System.err); // 栈跟踪信息也可以重定向到错误流
        }

        System.out.println("程序正常结束。");
    }
}
```

#### 4. 重定向标准 I/O

Java 允许你重定向 `System.in`, `System.out`, 和 `System.err`，将它们指向文件或其他流，而不是默认的控制台。这对于日志记录、自动化测试或特定应用场景非常有用。

* `System.setIn(InputStream is)`: 设置新的标准输入流。
* `System.setOut(PrintStream ps)`: 设置新的标准输出流。
* `System.setErr(PrintStream ps)`: 设置新的标准错误流。

**重定向示例：**

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.io.IOException;

public class RedirectStandardIODemo {
    public static void main(String[] args) {
        PrintStream oldOut = System.out; // 保存原始的 System.out
        PrintStream oldErr = System.err; // 保存原始的 System.err

        try {
            // 将 System.out 重定向到文件 output.log
            PrintStream fileOut = new PrintStream(new FileOutputStream("output.log"));
            System.setOut(fileOut);
            System.out.println("这条消息被写入到 output.log 文件中。");

            // 将 System.err 重定向到文件 error.log
            PrintStream fileErr = new PrintStream(new FileOutputStream("error.log"));
            System.setErr(fileErr);
            System.err.println("这条错误信息被写入到 error.log 文件中。");

            // 读取重定向后的输入 (需要先创建 input.txt 文件并输入内容)
            // System.setIn(new FileInputStream("input.txt"));
            // Scanner scanner = new Scanner(System.in);
            // System.out.println("从文件中读取到：" + scanner.nextLine()); // 这条输出也会进 output.log

        } catch (IOException e) {
            // 此时，System.err 已经重定向，所以此错误也会写入 error.log
            System.err.println("重定向发生错误：" + e.getMessage());
        } finally {
            // 恢复原始的 System.out 和 System.err，非常重要！
            System.setOut(oldOut);
            System.setErr(oldErr);
            System.out.println("标准输出和错误流已恢复到控制台。");
        }
    }
}
```

#### 总结

Java 的标准输入输出机制是程序与用户/环境交互的基础。通过 `System.in`、`System.out` 和 `System.err`，我们可以方便地进行控制台的输入输出。在使用 `System.in` 时，通常需要结合 `Scanner` 或 `BufferedReader` 来进行更高级的文本和数据读取。而 `System.out` 和 `System.err` 则直接提供了便捷的打印方法，分别用于正常输出和错误/调试输出。理解并合理运用这些标准流，对于程序的调试、日志记录和用户交互都至关重要。
## 对象的串行化
我们来详细讲解 Java 中的**对象的串行化 (Serialization)**。

---

### Java 中的对象的串行化 (Serialization) 详解

在 Java 中，**对象的串行化 (Serialization)** 是一种将对象的状态转换为字节序列的过程。这个字节序列可以被存储到磁盘上（持久化），也可以通过网络传输到另一个 JVM，然后在需要的时候将这些字节序列恢复成原来的对象（这个过程称为**反串行化 / Deserialization**）。

串行化是 Java 提供的一种轻量级、内置的对象持久化和数据传输机制。

#### 1. 为什么需要对象的串行化？

在以下场景中，对象串行化变得至关重要：

1.  **对象持久化：** 将内存中的对象状态保存到文件、数据库或其他存储介质中，以便程序关闭后下次启动时能恢复对象。
2.  **网络传输：** 在分布式应用中（如 RMI、JMS、EJB），对象需要在不同的 JVM 之间传输。串行化将对象转换为字节流，使其可以在网络上传输。
3.  **进程间通信：** 在同一个机器上不同 Java 进程间传递对象。
4.  **缓存：** 将对象缓存到内存或文件，以便快速恢复。
5.  **克隆 (Deep Copy)：** 通过将对象序列化再反序列化，可以实现对象的深拷贝。

#### 2. 实现对象串行化

要使一个 Java 对象能够被串行化，它所属的类必须满足以下条件：

1.  **实现 `java.io.Serializable` 接口：** 这是一个**标记接口 (Marker Interface)**，它不包含任何方法，仅用于向 JVM 标记该类的对象是可以被序列化的。如果一个类没有实现 `Serializable` 接口，但其对象被尝试序列化，则会抛出 `NotSerializableException`。
2.  **所有非 `static` 和非 `transient` 的字段都必须是可序列化的：**
    * 如果某个字段本身是一个对象，那么这个对象的类也必须是可序列化的（即也实现了 `Serializable` 接口），否则会抛出 `NotSerializableException`。
    * **`static` 字段：** `static` 字段属于类，不属于对象实例，因此它们不会被序列化。
    * **`transient` 字段：** `transient` 关键字用于标记不希望被序列化的实例字段。被 `transient` 修饰的字段在对象序列化时会被跳过，反序列化后其值为对应数据类型的默认值（例如，`int` 为 0，`Object` 为 `null`）。这在某些敏感信息（如密码）或不适合序列化的资源（如文件句柄、网络连接）时非常有用。
3.  **（可选）定义 `serialVersionUID`：** 这是一个 `long` 类型的静态常量，用于在序列化和反序列化时进行版本控制。如果 `serialVersionUID` 不匹配，反序列化时会抛出 `InvalidClassException`。显式定义它有助于保持类的兼容性。
    * 如果不定义，JVM 会根据类的结构自动生成一个。但如果类的结构在序列化后发生了变化，JVM 自动生成的 `serialVersionUID` 也会变化，可能导致反序列化失败。显式定义则可以避免这种情况。

#### 3. 串行化和反串行化的工具类

Java 提供了专门的字节流来执行对象的串行化和反串行化：

1.  **`java.io.ObjectOutputStream`：**
    * 用于将 Java 对象转换为字节序列并写入到 `OutputStream`。
    * **核心方法：** `void writeObject(Object obj)`
2.  **`java.io.ObjectInputStream`：**
    * 用于从 `InputStream` 读取字节序列并将其恢复为 Java 对象。
    * **核心方法：** `Object readObject()` (返回一个 `Object` 类型，需要强制类型转换)

这些类通常需要包装在文件流或其他字节流之上。

#### 4. 串行化示例

**步骤：**

1.  **定义可序列化类：** 创建一个类并实现 `Serializable` 接口。
2.  **序列化对象：**
    * 创建 `FileOutputStream` 来指定输出文件。
    * 将 `FileOutputStream` 包装到 `ObjectOutputStream` 中。
    * 调用 `ObjectOutputStream.writeObject()` 方法写入对象。
    * 关闭流。
3.  **反序列化对象：**
    * 创建 `FileInputStream` 来指定输入文件。
    * 将 `FileInputStream` 包装到 `ObjectInputStream` 中。
    * 调用 `ObjectInputStream.readObject()` 方法读取对象。
    * 将返回的 `Object` 强制转换为原始类型。
    * 关闭流。

```java
import java.io.*; // 导入所有必要的 I/O 类

// 1. 定义一个可序列化的学生类
class Student implements Serializable {
    // 推荐定义 serialVersionUID，用于版本控制
    private static final long serialVersionUID = 1L;

    private String name;
    private int age;
    private String studentId;
    // 使用 transient 关键字，表示这个字段不参与序列化
    private transient String password; // 假设密码不应被持久化

    // 构造器
    public Student(String name, int age, String studentId, String password) {
        this.name = name;
        this.age = age;
        this.studentId = studentId;
        this.password = password;
    }

    // Getter 方法
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getStudentId() {
        return studentId;
    }

    public String getPassword() {
        return password;
    }

    @Override
    public String toString() {
        return "Student{" +
               "name='" + name + '\'' +
               ", age=" + age +
               ", studentId='" + studentId + '\'' +
               ", password='" + password + '\'' + // 注意：反序列化后 password 会是 null
               '}';
    }
}

public class SerializationDemo {

    private static final String FILE_NAME = "student.ser";

    public static void main(String[] args) {

        // --- 序列化对象 ---
        Student originalStudent = new Student("Alice", 20, "S12345", "mySecretPass");
        System.out.println("原始对象: " + originalStudent);

        try (FileOutputStream fileOut = new FileOutputStream(FILE_NAME);
             ObjectOutputStream out = new ObjectOutputStream(fileOut)) {

            out.writeObject(originalStudent); // 将对象写入到文件
            System.out.println("对象已成功序列化到 " + FILE_NAME);

        } catch (IOException i) {
            i.printStackTrace();
        }

        // --- 反序列化对象 ---
        Student deserializedStudent = null;
        try (FileInputStream fileIn = new FileInputStream(FILE_NAME);
             ObjectInputStream in = new ObjectInputStream(fileIn)) {

            // 从文件中读取对象，并进行强制类型转换
            deserializedStudent = (Student) in.readObject();
            System.out.println("对象已成功反序列化。");

        } catch (IOException i) {
            i.printStackTrace();
            return;
        } catch (ClassNotFoundException c) {
            // 当反序列化时，找不到对象的类定义会抛出此异常
            System.out.println("Student class not found.");
            c.printStackTrace();
            return;
        }

        System.out.println("反序列化后的对象: " + deserializedStudent);
        // 注意：反序列化后，transient 字段 password 的值是 null
        System.out.println("反序列化后密码 (transient): " + deserializedStudent.getPassword());

        // 验证两个对象是否是同一个（通过内存地址）
        System.out.println("原始对象和反序列化对象是否是同一个实例？ " + (originalStudent == deserializedStudent)); // False
        System.out.println("原始对象和反序列化对象的内容是否相等？ " + originalStudent.getName().equals(deserializedStudent.getName())); // True (如果字段内容相同)

        // 清理文件 (可选)
        // new File(FILE_NAME).delete();
    }
}
```

#### 5. 序列化的底层原理 (简述)

当一个对象被序列化时，JVM 会：

1.  递归地检查对象的所有非 `static` 和非 `transient` 字段。
2.  如果字段是基本数据类型，直接将其值写入字节流。
3.  如果字段是另一个对象，JVM 会递归地序列化那个对象。
4.  为了处理对象图中可能存在的循环引用和重复引用，JVM 会为每个已序列化的对象分配一个唯一 ID，并在遇到重复引用时写入该 ID，而不是再次序列化整个对象。
5.  最终生成一个包含对象所有可序列化状态的字节序列。

#### 6. 序列化的优缺点

**优点：**

* **简单易用：** 只需实现 `Serializable` 接口，Java 就会自动处理大部分序列化细节。
* **内置支持：** Java 语言和标准库自带支持，无需额外引入第三方库。
* **持久化和网络传输：** 是实现对象持久化和分布式应用中对象传输的基础。

**缺点：**

* **兼容性问题：** 类的结构变化可能导致 `InvalidClassException`，需要 `serialVersionUID` 来管理版本兼容性。
* **安全性问题：** 默认的序列化机制是基于字节流的，存在安全漏洞的风险（如反序列化漏洞），需要谨慎对待。
* **性能开销：** 默认的序列化通常比专门的数据格式（如 JSON, Protobuf）效率低，生成的字节流较大，速度可能较慢。
* **耦合性：** 序列化格式与 Java 特定，与其他语言交互不便。

#### 7. 替代方案

鉴于 Java 默认序列化的一些缺点，尤其是在跨语言通信和高性能场景下，现代 Java 应用更倾向于使用以下替代方案：

* **JSON：** 轻量级的数据交换格式，易于人阅读和编写，也易于机器解析和生成。有 Fastjson, Jackson, Gson 等流行库。
* **XML：** 更为笨重，但可扩展性强，常用于配置文件和Web服务。
* **Protocol Buffers (Protobuf) / Apache Thrift：** 高效的二进制序列化协议，由 Google 和 Apache 开发，适用于高性能、跨语言的数据传输。

尽管有这些替代方案，Java 的内置序列化在某些特定场景（如 Java RMI、本地对象持久化）仍然被广泛使用。理解其工作原理和限制，对于任何 Java 开发者都是非常重要的。